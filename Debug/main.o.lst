   1              	 .syntax unified
   2              	 .cpu cortex-m4
   3              	 .eabi_attribute 27,3
   4              	 .fpu fpv4-sp-d16
   5              	 .eabi_attribute 20,1
   6              	 .eabi_attribute 21,1
   7              	 .eabi_attribute 23,3
   8              	 .eabi_attribute 24,1
   9              	 .eabi_attribute 25,1
  10              	 .eabi_attribute 26,1
  11              	 .eabi_attribute 30,6
  12              	 .eabi_attribute 34,1
  13              	 .eabi_attribute 18,4
  14              	 .thumb
  15              	 .file "main.c"
  16              	 .text
  17              	.Ltext0:
  18              	 .cfi_sections .debug_frame
  19              	 .section .text.XMC_GPIO_SetOutputHigh,"ax",%progbits
  20              	 .align 2
  21              	 .thumb
  22              	 .thumb_func
  24              	XMC_GPIO_SetOutputHigh:
  25              	.LFB155:
  26              	 .file 1 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Libraries\\XMCLib\\inc/xmc_gpio.h"
   1:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
   2:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @file xmc_gpio.h
   3:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @date 2016-01-12
   4:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
   5:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @cond
   6:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   *************************************************************************************************
   7:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   8:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
   9:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  10:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * All rights reserved.                        
  11:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *                                             
  12:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * following conditions are met:   
  14:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *                                                                              
  15:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * disclaimer.                        
  17:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * 
  18:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * 
  21:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * products derived from this software without specific prior written permission.                  
  23:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *                                                                              
  24:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *                                                                              
  32:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  **************************************************************************************************
  35:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
  36:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Change History
  37:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * --------------
  38:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
  39:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * 2015-02-20:
  40:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *     - Initial draft<br>
  41:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *     - Documentation improved <br>
  42:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *      
  43:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * 2015-06-20:
  44:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  45:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
  46:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @endcond
  47:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
  48:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
  49:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
  50:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #ifndef XMC_GPIO_H
  51:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #define XMC_GPIO_H
  52:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
  53:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**************************************************************************************************
  54:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * HEADER FILES
  55:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  **************************************************************************************************
  56:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
  57:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #include "xmc_common.h"
  58:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
  59:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
  60:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @addtogroup XMClib XMC Peripheral Library
  61:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @{
  62:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
  63:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
  64:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
  65:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @addtogroup GPIO
  66:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @brief General Purpose Input Output (GPIO) driver for the XMC microcontroller family.
  67:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
  68:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * GPIO driver provide a generic and very flexible software interface for all standard digital I/O 
  69:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Each port slice has individual interfaces for the operation as General Purpose I/O and it furthe
  70:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * connectivity to the on-chip periphery and the control for the pad characteristics. 
  71:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
  72:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * The driver is divided into Input and Output mode.
  73:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
  74:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Input mode features:
  75:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * -# Configuration structure XMC_GPIO_CONFIG_t and initialization function XMC_GPIO_Init()
  76:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * -# Allows the selection of weak pull-up or pull-down device. Configuration structure XMC_GPIO_MO
  77:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \if XMC1
  78:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * -# Allows the selection of input hysteresis. XMC_GPIO_SetInputHysteresis()
  79:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \endif
  80:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
  81:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * 
  82:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Output mode features:
  83:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * -# Allows the selection of push pull/open drain and Alternate output. Configuration structure XM
  84:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \if XMC4
  85:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * -# Allows the selection of pad driver strength. Configuration structure XMC_GPIO_OUTPUT_STRENGTH
  86:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \endif
  87:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
  88:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * -# Allows the selection of initial output level. Configuration structure XMC_GPIO_OUTPUT_LEVEL_t
  89:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
  90:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *@{
  91:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
  92:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  
  93:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**************************************************************************************************
  94:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * MACROS
  95:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  **************************************************************************************************
  96:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
  97:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #define PORT_IOCR_PC_Pos PORT0_IOCR0_PC0_Pos
  98:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #define PORT_IOCR_PC_Msk PORT0_IOCR0_PC0_Msk
  99:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #define PORT_IOCR_PC_Size 				(8U)
 101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 											
 102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_OUTPUT_LEVEL(level) ((level == XMC_GPIO_OUTPUT_LEVEL_LOW) || \
 104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****                                             (level == XMC_GPIO_OUTPUT_LEVEL_HIGH))
 105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****                                             
 106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #define XMC_GPIO_CHECK_HWCTRL(hwctrl) ((hwctrl == XMC_GPIO_HWCTRL_DISABLED) || \
 107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL1) || \
 108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****                                        (hwctrl == XMC_GPIO_HWCTRL_PERIPHERAL2))                    
 109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****                                             
 110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**************************************************************************************************
 111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * ENUMS
 112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  **************************************************************************************************
 113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Defines output level of a pin. Use type \a XMC_GPIO_OUTPUT_LEVEL_t for this enum.
 117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** typedef enum XMC_GPIO_OUTPUT_LEVEL
 119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** {
 120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_LOW  = 0x10000U, /**<  Reset bit */
 121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_GPIO_OUTPUT_LEVEL_HIGH = 0x1U, 	/**< Set bit  */
 122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** } XMC_GPIO_OUTPUT_LEVEL_t;
 123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Defines direct hardware control characteristics of the pin . Use type \a XMC_GPIO_HWCTRL_t for t
 126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** typedef enum XMC_GPIO_HWCTRL
 128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** {
 129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_DISABLED     = 0x0U, /**<  Software control only */
 130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL1  = 0x1U, /**<  HWI0/HWO0 control path can override the software confi
 131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_GPIO_HWCTRL_PERIPHERAL2  = 0x2U  /**<  HWI1/HWO1 control path can override the software confi
 132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** } XMC_GPIO_HWCTRL_t;
 133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**************************************************************************************************
 135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * DEVICE FAMILY EXTENSIONS
 136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  **************************************************************************************************
 137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  #if UC_FAMILY == XMC1
 139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #include "xmc1_gpio.h"
 140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #elif UC_FAMILY == XMC4
 141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #include "xmc4_gpio.h"
 142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #else
 143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #error "xmc_gpio.h: family device not supported"
 144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #endif
 145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**************************************************************************************************
 147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * API PROTOTYPES
 148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  **************************************************************************************************
 149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #ifdef __cplusplus
 151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** extern "C" {
 152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** #endif
 153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  port	  Constant pointer pointing to GPIO port, to access port registers like Pn_OUT,Pn_O
 157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  pin	  Port pin number.
 158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  config GPIO configuration data structure. Refer data structure @ref XMC_GPIO_CONFIG_t fo
 159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @return None
 161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \if XMC1
 164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,hysteresis, push pull
 165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for a selected \a po
 166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \a config provides selected I/O settings. It configures hardware registers Pn_IOCR,Pn_OUT, Pn_OM
 167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \endif
 168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \if XMC4
 169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Initializes input / output mode settings like, pull up / pull down devices,push pull /open drain
 170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Also configures alternate function outputs and clears hardware port control for selected \a port
 171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * It configures hardware registers Pn_IOCR,Pn_OUT,Pn_OMR,Pn_PDISC and Pn_PDR.\n
 172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \endif
 173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *  None
 176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * This API is called in definition of DAVE_init by code generation and therefore should not be exp
 179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * for the normal operation. Use other APIs only after DAVE_init is called successfully (returns DA
 180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  
 185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** void XMC_GPIO_Init(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_CONFIG_t *const c
 186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  
 187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  port	Constant pointer pointing to GPIO port, to access hardware register Pn_IOCR.
 190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  mode input / output functionality selection. Refer @ref XMC_GPIO_MODE_t for valid values
 192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @return None
 194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Sets digital input and output driver functionality and characteristics of a GPIO port pin. It co
 197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * registers Pn_IOCR. \a mode is initially configured during initialization in XMC_GPIO_Init(). Cal
 198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * the port direction functionality as needed later in the program.
 199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *  None
 202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** void XMC_GPIO_SetMode(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_MODE_t mode);
 206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  port	 Constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  pin	 Port pin number.
 212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  level output level selection. Refer @ref XMC_GPIO_OUTPUT_LEVEL_t for valid values.
 213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @return None
 215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Set port pin output level to high or low.It configures hardware registers Pn_OMR.\a level is ini
 218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * configured during initialization in XMC_GPIO_Init(). Call this API to alter output level as need
 219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLevel(XMC_GPIO_PORT_t *const port, const uint8_t pin, const 
 230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** {
 231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLevel: Invalid output level", XMC_GPIO_CHECK_OUTPUT_LEVEL(level));
 233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   
 234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   port->OMR = (uint32_t)level << pin;
 235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** }
 236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  pin	Port pin number.
 241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @return None
 243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *  Sets port pin output to high. It configures hardware registers Pn_OMR.
 246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *  \par<b>Related APIs:</b><BR>
 248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *  XMC_GPIO_SetOutputLow()
 249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().\n
 252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputHigh(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** {
  27              	 .loc 1 257 0
  28              	 .cfi_startproc
  29              	 
  30              	 
  31              	 
  32 0000 80B4     	 push {r7}
  33              	.LCFI0:
  34              	 .cfi_def_cfa_offset 4
  35              	 .cfi_offset 7,-4
  36 0002 83B0     	 sub sp,sp,#12
  37              	.LCFI1:
  38              	 .cfi_def_cfa_offset 16
  39 0004 00AF     	 add r7,sp,#0
  40              	.LCFI2:
  41              	 .cfi_def_cfa_register 7
  42 0006 7860     	 str r0,[r7,#4]
  43 0008 0B46     	 mov r3,r1
  44 000a FB70     	 strb r3,[r7,#3]
 258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputHigh: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   port->OMR = (uint32_t)0x1U << pin;
  45              	 .loc 1 260 0
  46 000c FB78     	 ldrb r3,[r7,#3]
  47 000e 0122     	 movs r2,#1
  48 0010 9A40     	 lsls r2,r2,r3
  49 0012 7B68     	 ldr r3,[r7,#4]
  50 0014 5A60     	 str r2,[r3,#4]
 261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** }
  51              	 .loc 1 261 0
  52 0016 0C37     	 adds r7,r7,#12
  53              	.LCFI3:
  54              	 .cfi_def_cfa_offset 4
  55 0018 BD46     	 mov sp,r7
  56              	.LCFI4:
  57              	 .cfi_def_cfa_register 13
  58              	 
  59 001a 5DF8047B 	 ldr r7,[sp],#4
  60              	.LCFI5:
  61              	 .cfi_restore 7
  62              	 .cfi_def_cfa_offset 0
  63 001e 7047     	 bx lr
  64              	 .cfi_endproc
  65              	.LFE155:
  67              	 .section .text.XMC_GPIO_SetOutputLow,"ax",%progbits
  68              	 .align 2
  69              	 .thumb
  70              	 .thumb_func
  72              	XMC_GPIO_SetOutputLow:
  73              	.LFB156:
 262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  port	constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param  pin	port pin number.
 267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @return  None
 269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Sets port pin output to low. It configures hardware registers Pn_OMR.\n
 272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>>
 274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh()
 275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *\par<b>Note:</b><br>
 277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode().
 278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Register Pn_OMR is virtual and does not contain any flip-flop. A read action delivers the value 
 279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_SetOutputLow(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** {
  74              	 .loc 1 283 0
  75              	 .cfi_startproc
  76              	 
  77              	 
  78              	 
  79 0000 80B4     	 push {r7}
  80              	.LCFI6:
  81              	 .cfi_def_cfa_offset 4
  82              	 .cfi_offset 7,-4
  83 0002 83B0     	 sub sp,sp,#12
  84              	.LCFI7:
  85              	 .cfi_def_cfa_offset 16
  86 0004 00AF     	 add r7,sp,#0
  87              	.LCFI8:
  88              	 .cfi_def_cfa_register 7
  89 0006 7860     	 str r0,[r7,#4]
  90 0008 0B46     	 mov r3,r1
  91 000a FB70     	 strb r3,[r7,#3]
 284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_SetOutputLow: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   port->OMR = 0x10000U << pin;
  92              	 .loc 1 286 0
  93 000c FB78     	 ldrb r3,[r7,#3]
  94 000e 4FF48032 	 mov r2,#65536
  95 0012 9A40     	 lsls r2,r2,r3
  96 0014 7B68     	 ldr r3,[r7,#4]
  97 0016 5A60     	 str r2,[r3,#4]
 287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** }
  98              	 .loc 1 287 0
  99 0018 0C37     	 adds r7,r7,#12
 100              	.LCFI9:
 101              	 .cfi_def_cfa_offset 4
 102 001a BD46     	 mov sp,r7
 103              	.LCFI10:
 104              	 .cfi_def_cfa_register 13
 105              	 
 106 001c 5DF8047B 	 ldr r7,[sp],#4
 107              	.LCFI11:
 108              	 .cfi_restore 7
 109              	 .cfi_def_cfa_offset 0
 110 0020 7047     	 bx lr
 111              	 .cfi_endproc
 112              	.LFE156:
 114 0022 00BF     	 .section .text.XMC_GPIO_GetInput,"ax",%progbits
 115              	 .align 2
 116              	 .thumb
 117              	 .thumb_func
 119              	XMC_GPIO_GetInput:
 120              	.LFB158:
 288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_OMR.
 292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param pin  port pin number.
 293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @return None
 295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Configures port pin output to Toggle. It configures hardware registers Pn_OMR.
 298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * XMC_GPIO_SetOutputHigh(), XMC_GPIO_SetOutputLow().
 301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to output mode using XMC_GPIO_SetMode(). Regis
 304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * and does not contain any flip-flop. A read action delivers the value of 0.
 305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_ToggleOutput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** {
 310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_ToggleOutput: Invalid port", XMC_GPIO_CHECK_OUTPUT_PORT(port));
 311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   port->OMR = 0x10001U << pin;
 313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** }
 314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_IN.
 318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param pin  Port pin number.
 319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @return uint32_t pin logic level status.
 321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *\par<b>Description:</b><br>
 323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Reads the Pn_IN register and returns the current logical value at the GPIO pin.
 324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * None
 327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Note:</b><br>
 329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Prior to this api, user has to configure port pin to input mode using XMC_GPIO_SetMode().
 330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** __STATIC_INLINE uint32_t XMC_GPIO_GetInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** {
 121              	 .loc 1 334 0
 122              	 .cfi_startproc
 123              	 
 124              	 
 125              	 
 126 0000 80B4     	 push {r7}
 127              	.LCFI12:
 128              	 .cfi_def_cfa_offset 4
 129              	 .cfi_offset 7,-4
 130 0002 83B0     	 sub sp,sp,#12
 131              	.LCFI13:
 132              	 .cfi_def_cfa_offset 16
 133 0004 00AF     	 add r7,sp,#0
 134              	.LCFI14:
 135              	 .cfi_def_cfa_register 7
 136 0006 7860     	 str r0,[r7,#4]
 137 0008 0B46     	 mov r3,r1
 138 000a FB70     	 strb r3,[r7,#3]
 335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_GetInput: Invalid port", XMC_GPIO_CHECK_PORT(port));
 336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   return (((port->IN) >> pin) & 0x1U);
 139              	 .loc 1 337 0
 140 000c 7B68     	 ldr r3,[r7,#4]
 141 000e 5A6A     	 ldr r2,[r3,#36]
 142 0010 FB78     	 ldrb r3,[r7,#3]
 143 0012 22FA03F3 	 lsr r3,r2,r3
 144 0016 03F00103 	 and r3,r3,#1
 338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** }
 145              	 .loc 1 338 0
 146 001a 1846     	 mov r0,r3
 147 001c 0C37     	 adds r7,r7,#12
 148              	.LCFI15:
 149              	 .cfi_def_cfa_offset 4
 150 001e BD46     	 mov sp,r7
 151              	.LCFI16:
 152              	 .cfi_def_cfa_register 13
 153              	 
 154 0020 5DF8047B 	 ldr r7,[sp],#4
 155              	.LCFI17:
 156              	 .cfi_restore 7
 157              	 .cfi_def_cfa_offset 0
 158 0024 7047     	 bx lr
 159              	 .cfi_endproc
 160              	.LFE158:
 162 0026 00BF     	 .section .text.XMC_GPIO_EnableDigitalInput,"ax",%progbits
 163              	 .align 2
 164              	 .thumb
 165              	 .thumb_func
 167              	XMC_GPIO_EnableDigitalInput:
 168              	.LFB161:
 339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param port constant pointer pointing to GPIO port, to access hardware register Pn_PPS.
 342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param pin  port pin number.
 343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @return None
 345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Enables pin power save mode and configures Pn_PPS register.This configuration is useful when the
 348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Deep Sleep mode.Port pin enabled with power save mode option are set to a defined state and the 
 349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * as well as the output driver stage are switched off. By default port pin does not react to power
 350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * XMC_GPIO_DisablePowerSaveMode()
 353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * <b>Note:</b><br>
 355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Do not enable the Pin Power Save function for pins configured for Hardware Control (Pn_HWSEL.HWx
 356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * may result in an undefined behavior of the pin when the device enters the Deep Sleep state.
 357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_EnablePowerSaveMode(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** {
 363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_EnablePowerSaveMode: Invalid port", XMC_GPIO_CHECK_PORT(port));
 364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   port->PPS |= (uint32_t)0x1U << pin;
 366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** }
 367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param port	constant pointer pointing to GPIO port, to access hardware register Pn_PPS.
 372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param pin	port pin number.
 373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @return None
 375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 376:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 377:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Disables pin power save mode and configures Pn_PPS register.This configuration is useful when th
 378:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Deep Sleep mode. This configuration enables input Schmitt-Trigger and output driver stage(if pin
 379:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * save mode previously). By default port \a pin does not react to power save mode request.
 380:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 381:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 382:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *  XMC_GPIO_EnablePowerSaveMode()
 383:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 384:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *\par<b>Note:</b><br>
 385:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Do not enable the Pin Power Save function for pins configured for Hardware Control (Pn_HWSEL.HWx
 386:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * may result in an undefined behavior of the pin when the device enters the Deep Sleep state.
 387:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 388:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 389:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 390:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_DisablePowerSaveMode(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 391:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** {
 392:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_DisablePowerSaveMode: Invalid port", XMC_GPIO_CHECK_PORT(port));
 393:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 394:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   port->PPS &= ~(uint32_t)((uint32_t)0x1U << pin);
 395:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** }
 396:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 397:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 398:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 399:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param port	 constant pointer pointing to GPIO port, to access hardware register Pn_HWSEL.
 400:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param pin	 port pin number.
 401:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param hwctrl direct hardware control selection. Refer @ref XMC_GPIO_HWCTRL_t for valid values.
 402:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 403:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @return None
 404:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 405:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 406:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Selects direct hard ware control and configures Pn_HWSEL register.This configuration is useful f
 407:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * overlaid with peripheral functions for which the connected peripheral needs hardware control.
 408:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 409:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 410:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *  None
 411:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 412:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *\par<b>Note:</b><br>
 413:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Do not enable the Pin Power Save function for pins configured for Hardware Control (Pn_HWSEL.HWx
 414:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Doing so may result in an undefined behavior of the pin when the device enters the Deep Sleep st
 415:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 416:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 417:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 418:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** void XMC_GPIO_SetHardwareControl(XMC_GPIO_PORT_t *const port, const uint8_t pin, const XMC_GPIO_HWC
 419:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 420:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** 
 421:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** /**
 422:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param port	constant pointer pointing to GPIO port, to access hardware register Pn_PDISC.
 423:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @param pin	port pin number.
 424:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 425:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * @return None
 426:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 427:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Related APIs:</b><BR>
 428:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *  None
 429:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 430:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * \par<b>Description:</b><br>
 431:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * Enable digital input path for analog pins and configures Pn_PDISC register.This configuration is
 432:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  * analog port pins.
 433:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  *
 434:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****  */
 435:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** __STATIC_INLINE void XMC_GPIO_EnableDigitalInput(XMC_GPIO_PORT_t *const port, const uint8_t pin)
 436:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** {
 169              	 .loc 1 436 0
 170              	 .cfi_startproc
 171              	 
 172              	 
 173              	 
 174 0000 80B4     	 push {r7}
 175              	.LCFI18:
 176              	 .cfi_def_cfa_offset 4
 177              	 .cfi_offset 7,-4
 178 0002 83B0     	 sub sp,sp,#12
 179              	.LCFI19:
 180              	 .cfi_def_cfa_offset 16
 181 0004 00AF     	 add r7,sp,#0
 182              	.LCFI20:
 183              	 .cfi_def_cfa_register 7
 184 0006 7860     	 str r0,[r7,#4]
 185 0008 0B46     	 mov r3,r1
 186 000a FB70     	 strb r3,[r7,#3]
 437:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   XMC_ASSERT("XMC_GPIO_EnableDigitalInput: Invalid analog port", XMC_GPIO_CHECK_ANALOG_PORT(port));
 438:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   
 439:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h ****   port->PDISC &= ~(uint32_t)((uint32_t)0x1U << pin);
 187              	 .loc 1 439 0
 188 000c 7B68     	 ldr r3,[r7,#4]
 189 000e 1A6E     	 ldr r2,[r3,#96]
 190 0010 FB78     	 ldrb r3,[r7,#3]
 191 0012 0121     	 movs r1,#1
 192 0014 01FA03F3 	 lsl r3,r1,r3
 193 0018 DB43     	 mvns r3,r3
 194 001a 1A40     	 ands r2,r2,r3
 195 001c 7B68     	 ldr r3,[r7,#4]
 196 001e 1A66     	 str r2,[r3,#96]
 440:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_gpio.h **** }
 197              	 .loc 1 440 0
 198 0020 0C37     	 adds r7,r7,#12
 199              	.LCFI21:
 200              	 .cfi_def_cfa_offset 4
 201 0022 BD46     	 mov sp,r7
 202              	.LCFI22:
 203              	 .cfi_def_cfa_register 13
 204              	 
 205 0024 5DF8047B 	 ldr r7,[sp],#4
 206              	.LCFI23:
 207              	 .cfi_restore 7
 208              	 .cfi_def_cfa_offset 0
 209 0028 7047     	 bx lr
 210              	 .cfi_endproc
 211              	.LFE161:
 213 002a 00BF     	 .section .text.XMC_CAN_NODE_SetInitBit,"ax",%progbits
 214              	 .align 2
 215              	 .thumb
 216              	 .thumb_func
 218              	XMC_CAN_NODE_SetInitBit:
 219              	.LFB199:
 220              	 .file 2 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Libraries\\XMCLib\\inc/xmc_can.h"
   1:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
   2:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @file xmc_can.h
   3:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @date 2016-01-12
   4:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
   5:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @cond
   6:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  **************************************************************************************************
   7:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMClib v2.1.6 - XMC Peripheral Driver Library 
   8:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
   9:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Copyright (c) 2015-2016, Infineon Technologies AG
  10:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * All rights reserved.                        
  11:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *                                             
  12:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Redistribution and use in source and binary forms, with or without modification,are permitted pr
  13:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * following conditions are met:   
  14:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *                                                                              
  15:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Redistributions of source code must retain the above copyright notice, this list of conditions a
  16:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * disclaimer.                        
  17:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 
  18:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Redistributions in binary form must reproduce the above copyright notice, this list of condition
  19:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * disclaimer in the documentation and/or other materials provided with the distribution.          
  20:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 
  21:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Neither the name of the copyright holders nor the names of its contributors may be used to endor
  22:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * products derived from this software without specific prior written permission.                  
  23:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *                                                                              
  24:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR I
  25:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTI
  26:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE  FOR ANY DIRECT, IN
  27:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBS
  28:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THE
  29:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
  30:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                            
  31:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *                                                                              
  32:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * To improve the quality of the software, users are encouraged to share modifications, enhancement
  33:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Infineon Technologies AG dave@infineon.com).                                                    
  34:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  **************************************************************************************************
  35:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
  36:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Change History
  37:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * --------------
  38:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
  39:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 2015-02-20:
  40:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *     - Initial <br>
  41:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *     - Documentation improved <br>
  42:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
  43:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 2015-05-20:
  44:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *     - New elements have added in XMC_CAN_MO_t data structure <br>
  45:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *     - XMC_CAN_MO_Config() signature has changed <br>
  46:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *     - XMC_CAN_STATUS_t enum structure has updated. <br>
  47:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
  48:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 2015-06-20:
  49:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *     - New APIs added: XMC_CAN_NODE_ClearStatus(),XMC_CAN_MO_ReceiveData(), XMC_CAN_GATEWAY_InitD
  50:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *     - Removed version macros and declaration of GetDriverVersion API
  51:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *      
  52:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 2015-07-09:
  53:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *     - New API added: XMC_CAN_NODE_Enable. <br>
  54:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
  55:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 2015-09-01:
  56:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *     - Removed fCANB clock support <br>
  57:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
  58:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 2015-09-15:
  59:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *     - Added "xmc_can_map.h" include <br>
  60:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * <b>Details of use for node configuration related APIs</b><br>
  61:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Please use the XMC_CAN_NODE_SetInitBit() and XMC_CAN_NODE_EnableConfigurationChange() before cal
  62:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * related APIs.
  63:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_DisableConfigurationChange() and  XMC_CAN_NODE_ResetInitBit() can be called for dis
  64:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * change and enable the node for communication afterwards.
  65:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Do not use this when configuring the nominal bit time with XMC_CAN_NODE_NominalBitTimeConfigure(
  66:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Enable/Disable node configuration change is taken in account.
  67:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
  68:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * <b>Example Usage:</b>
  69:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @code
  70:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * //disabling the Node
  71:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_SetInitBit(CAN_NODE0)
  72:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * //allowing the configuration change
  73:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_EnableConfigurationChange(CAN_NODE0)
  74:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * //Node configuration
  75:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_FrameCounterConfigure(CAN_NODE0,&can_node_frame_counter);
  76:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_EnableLoopBack(CAN_NODE0)
  77:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * //disable configuration
  78:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_DisableConfigurationChange(CAN_NODE0)
  79:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * //Enabling node for communication
  80:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_ResetInitBit(CAN_NODE0)
  81:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @endcode
  82:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
  83:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @endcond
  84:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
  85:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
  86:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
  87:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #ifndef XMC_CAN_H
  88:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #define XMC_CAN_H
  89:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
  90:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**************************************************************************************************
  91:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * HEADER FILES
  92:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  **************************************************************************************************
  93:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #include "xmc_common.h"
  94:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
  95:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #if defined(CAN)
  96:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
  97:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #include "xmc_scu.h"
  98:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #include "xmc_can_map.h"
  99:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #include <string.h>
 100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @addtogroup XMClib XMC Peripheral Library
 103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @{
 104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @addtogroup CAN
 108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @brief Controller Area Network Controller (CAN) driver for the XMC microcontroller family.
 109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * CAN driver provides transfer of CAN frames in accordance with CAN specificetion V2.0 B (active).
 111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * can receive and transmit standard frames with 11-bit identifiers as well as extended frames with
 112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * All CAN nodes share a common set of message objects. Each message object can be individually all
 113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * CAN nodes. 
 114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Besides serving as a storage container for incoming and outgoing frames, message objects can be 
 115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * gateways between 
 116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * the CAN nodes or to setup a FIFO buffer. The CAN module provides Analyzer mode,Loop-back mode an
 117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * node analysis.
 118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 
 119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * The driver is divided into five sections:
 120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par CAN Global features:
 121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Allows to configure module frequency using function XMC_CAN_Init().
 122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Allows to configure Module interrupt using configuration structure XMC_CAN_NODE_INTERRUPT_TRI
 123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *    XMC_CAN_EventTrigger().
 124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 
 125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par CAN_NODE features:
 126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Allows to set baud rate by configuration structure XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t and
 127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *    function XMC_CAN_NODE_NominalBitTimeConfigure().
 128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Allows to configure loop-back mode using fuction XMC_CAN_NODE_EnableLoopBack().
 129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Allows to configure CAN Node analyzer using function XMC_CAN_NODE_SetAnalyzerMode().
 130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Allows CAN node events enable/ disable by enum structure XMC_CAN_NODE_EVENT_t and functions X
 131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *    and XMC_CAN_NODE_DisableEvent().
 132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Provides bit timming analysis, configuration structure XMC_CAN_NODE_FRAME_COUNTER_t and funct
 133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *    XMC_CAN_NODE_FrameCounterConfigure(). 
 134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par CAN_MO features:
 136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Allows message object initialization by configuration structure XMC_CAN_MO_t and function XMC
 137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Allows transfer of message objects using functions XMC_CAN_MO_Transmit() and XMC_CAN_MO_Recei
 138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Allows to configure Single Data Transfer and Single Transmit Trial using functions 
 139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_MO_EnableSingleTransmitTrial() and XMC_CAN_MO_EnableSingleTransmitTrial().
 140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Allows to configure MO events using function XMC_CAN_MO_EnableEvent(). 
 141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par CAN_FIFO features:
 143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Allows message object FIFO structure by configuration structure XMC_CAN_FIFO_CONFIG_t and fun
 144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_TXFIFO_ConfigMOBaseObject() , XMC_CAN_RXFIFO_ConfigMOBaseObject() and XMC_CAN_TXFIFO_Tra
 145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par CAN_GATEWAY features:
 147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * -# Provides Gateway mode, configuration structure XMC_CAN_GATEWAY_CONFIG_t and function XMC_CAN_
 148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @{
 150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**************************************************************************************************
 153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * MACROS
 154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  **************************************************************************************************
 155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #define XMC_CAN_MO_MOAR_STDID_Pos (18U)		/**< Standard Identifier bitposition */
 156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #define XMC_CAN_MO_MOAR_STDID_Msk ((0x000007FFUL) << XMC_CAN_MO_MOAR_STDID_Pos) /**< Standard Ident
 158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #define CAN_NODE_NIPR_Msk         (0x7UL)	/**< Node event mask */
 160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #define CAN_MO_MOIPR_Msk          (0x7U)	/**< Message Object event mask */
 162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**************************************************************************************************
 164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * ENUMS
 165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  **************************************************************************************************
 166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Defines the status of CAN, to verify the CAN related API calls. Use type \a XMC_CAN_STATUS_t fo
 168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** */
 169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_STATUS
 170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_STATUS_SUCCESS,           /**< Driver accepted application request*/
 172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_STATUS_ERROR,             /**< Returned when unknown error occurred */
 173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_STATUS_BUSY,              /**< Driver is busy and can not handle request*/
 174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_STATUS_MO_NOT_ACCEPTABLE, /**< Message object type not allowed*/
 175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_STATUS_MO_DISABLED       /**< Returned if Message object is disabled */
 176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_STATUS_t;
 177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** * Defines CAN module Panel Commands . Use type \a XMC_CAN_PANCMD_t for this enum.
 180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** */
 181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_PANCMD
 182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_PANCMD_INIT_LIST = 1U,              /**< Command to initialize a list */
 184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_PANCMD_STATIC_ALLOCATE = 2U,        /**< Command to activate static allocation */
 185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_PANCMD_DYNAMIC_ALLOCATE = 3U,       /**< Command to activate dynamic allocation */
 186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_PANCMD_STATIC_INSERT_BEFORE = 4U,	  /**< Remove a message object from the list and insert
 188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_PANCMD_DYNAMIC_INSERT_BEFORE = 5U,  /**< Command to activate dynamic allocation */
 189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_PANCMD_STATIC_INSERT_BEHIND = 6U,   /**< Command to activate dynamic allocation */
 190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_PANCMD_DYNAMIC_INSERT_BEHIND = 7U   /**< Command to activate dynamic allocation */
 191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_PANCMD_t;
 192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** * Defines loop Back Mode, to enable/disable an in-system test of the MultiCAN module .
 195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** * Use type \a XMC_CAN_LOOKBACKMODE_t for this enum.
 196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** */
 197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_LOOKBACKMODE
 198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_LOOKBACKMODE_ENABLED,   /**< Each CAN node can be connected to the internal CAN bus  */
 200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_LOOKBACKMODE_DISABLED   /**< Each CAN node can be connected to the external CAN bus */
 201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_LOOKBACKMODE_t;
 202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines Message Object direction. Use type \a XMC_CAN_MO_TYPE_t for this enum.
 205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_MO_TYPE
 207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_TYPE_RECMSGOBJ,   /**< Receive Message Object selected */
 209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_TYPE_TRANSMSGOBJ  /**< Transmit Message Object selected */
 210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_MO_TYPE_t;
 211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines Data frame types. Use type \a XMC_CAN_FRAME_TYPE_t for this enum.
 214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_FRAME_TYPE
 216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_FRAME_TYPE_STANDARD_11BITS, /**< Standard type identifier*/
 218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_FRAME_TYPE_EXTENDED_29BITS  /**< Extended type identifier*/
 219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_FRAME_TYPE_t;
 220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines arbitration mode for transmit acceptance filtering. Use type \a XMC_CAN_ARBITRATION_MODE
 224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_ARBITRATION_MODE
 226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_ARBITRATION_MODE_ORDER_BASED_PRIO_1 = 1U,   /**< Transmit acceptance based in the order(p
 228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_ARBITRATION_MODE_IDE_DIR_BASED_PRIO_2 = 2U, /**< Transmit acceptance filtering is based o
 229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_ARBITRATION_MODE_ORDER_BASED_PRIO_3 = 3U    /**< Transmit acceptance based in the order *
 230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_ARBITRATION_MODE_t;
 231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines the operation mode of the frame counter. Use type \a XMC_CAN_FRAME_COUNT_MODE_t for this
 234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_FRAME_COUNT_MODE
 236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_FRAME_COUNT_MODE = 0U, 			 /**< Frame Count Mode */
 238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_FRAME_COUNT_MODE_TIME_STAMP = 1U,  /**< The frame counter is incremented with the beginni
 239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_FRAME_COUNT_MODE_BIT_TIMING = 2U   /**< Used for baud rate detection and analysis of the 
 240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_FRAME_COUNT_MODE_t;
 241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines the Divider Modes. Use type \a XMC_CAN_DM_t for this enum.
 244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_DM
 246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_DM_NORMAL = 1U,      /**< Normal divider mode */
 248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_DM_FRACTIONAL = 2U,  /**< Fractional divider mode */
 249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_DM_OFF = 3U          /**< Divider Mode in off-state*/
 250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_DM_t;
 251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines mask value for CAN Message Object set status. Use type \a XMC_CAN_MO_SET_STATUS_t for th
 254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_MO_SET_STATUS
 256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_RX_PENDING = CAN_MO_MOCTR_SETRXPND_Msk,     /**< Set receive pending */
 258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_TX_PENDING = CAN_MO_MOCTR_SETTXPND_Msk,     /**< Set transmit pending */
 259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_RX_UPDATING = CAN_MO_MOCTR_SETRXUPD_Msk,    /**< Set receive updating */
 260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_NEW_DATA = CAN_MO_MOCTR_SETNEWDAT_Msk,      /**< Set new data */
 261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_MESSAGE_LOST = CAN_MO_MOCTR_SETMSGLST_Msk,  /**< Set message lost */
 262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_MESSAGE_VALID = CAN_MO_MOCTR_SETMSGVAL_Msk, /**< Set message valid */
 263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_RX_TX_SELECTED = CAN_MO_MOCTR_SETRTSEL_Msk, /**< Set transmit/receive selec
 264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_RX_ENABLE = CAN_MO_MOCTR_SETRXEN_Msk,       /**< Set receive enable */
 265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_TX_REQUEST = CAN_MO_MOCTR_SETTXRQ_Msk,      /**< Set transmit request */
 266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_TX_ENABLE0 = CAN_MO_MOCTR_SETTXEN0_Msk,     /**< Set transmit enable 0 */
 267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_TX_ENABLE1 = CAN_MO_MOCTR_SETTXEN1_Msk,     /**< Set transmit enable 1 */
 268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_SET_STATUS_MESSAGE_DIRECTION = CAN_MO_MOCTR_SETDIR_Msk /**< Set message direction */
 269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_MO_SET_STATUS_t;
 270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines mask value for CAN Message Object reset status. Use type \a XMC_CAN_MO_RESET_STATUS_t fo
 273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_MO_RESET_STATUS
 275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_RX_PENDING = CAN_MO_MOCTR_RESRXPND_Msk,     /**< Reset receive pending */
 277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_TX_PENDING = CAN_MO_MOCTR_RESTXPND_Msk,     /**< Reset transmit pending *
 278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_RX_UPDATING = CAN_MO_MOCTR_RESRXUPD_Msk,    /**< Reset receive updating *
 279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_NEW_DATA = CAN_MO_MOCTR_RESNEWDAT_Msk,      /**< Reset new data */
 280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_MESSAGE_LOST = CAN_MO_MOCTR_RESMSGLST_Msk,  /**< Reset message lost */
 281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_MESSAGE_VALID = CAN_MO_MOCTR_RESMSGVAL_Msk, /**< Reset message valid */
 282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_RX_TX_SELECTED = CAN_MO_MOCTR_RESRTSEL_Msk, /**< Reset transmit/receive s
 283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_RX_ENABLE = CAN_MO_MOCTR_RESRXEN_Msk,       /**< Reset receive enable */
 284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_TX_REQUEST = CAN_MO_MOCTR_RESTXRQ_Msk,      /**< Reset transmit request *
 285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_TX_ENABLE0 = CAN_MO_MOCTR_RESTXEN0_Msk,     /**< Reset transmit enable 0 
 286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_TX_ENABLE1 = CAN_MO_MOCTR_RESTXEN1_Msk,     /**< Reset transmit enable 1 
 287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_RESET_STATUS_MESSAGE_DIRECTION = CAN_MO_MOCTR_RESDIR_Msk /**< Reset message direction 
 288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_MO_RESET_STATUS_t;
 289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines mask value for CAN Message Object status. Use type \a XMC_CAN_MO_STATUS_t for this enum.
 292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_MO_STATUS
 294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_RX_PENDING = CAN_MO_MOSTAT_RXPND_Msk,                   /**< Defines message ha
 296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_TX_PENDING = CAN_MO_MOSTAT_TXPND_Msk,                   /**< Defines message ha
 297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_RX_UPDATING = CAN_MO_MOSTAT_RXUPD_Msk,                  /**< Defines Message id
 298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_NEW_DATA = CAN_MO_MOSTAT_NEWDAT_Msk,                    /**< Defines no update 
 299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_MESSAGE_LOST = CAN_MO_MOSTAT_MSGLST_Msk,                /**< CAN message is los
 300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_MESSAGE_VALID = CAN_MO_MOSTAT_MSGVAL_Msk,               /**< Message valid */
 301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_RX_TX_SELECTED = CAN_MO_MOSTAT_RTSEL_Msk,               /**< Transmit/Receive s
 302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_RX_ENABLE = CAN_MO_MOSTAT_RXEN_Msk,                     /**< Receive enable */
 303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_TX_REQUEST = CAN_MO_MOSTAT_TXRQ_Msk,                    /**< Transmit request *
 304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_TX_ENABLE0 = CAN_MO_MOSTAT_TXEN0_Msk,                   /**< Transmit enable 0 
 305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_TX_ENABLE1 = CAN_MO_MOSTAT_TXEN1_Msk,                   /**< Transmit enable 1 
 306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_MESSAGE_DIRECTION = CAN_MO_MOSTAT_DIR_Msk,              /**< Message direction 
 307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_LIST = CAN_MO_MOSTAT_LIST_Msk,                          /**< List allocation */
 308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_POINTER_TO_PREVIOUS_MO = CAN_MO_MOSTAT_PPREV_Msk,    	/**< Pointer to previous 
 309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_STATUS_POINTER_TO_NEXT_MO = (int32_t)CAN_MO_MOSTAT_PNEXT_Msk   /**< Pointer to next Me
 310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_MO_STATUS_t;
 311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines mask value for CAN Node status. Use type \a XMC_CAN_NODE_STATUS_t for this enum.
 314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_NODE_STATUS
 316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_STATUS_LAST_ERROR_CODE = CAN_NODE_NSR_LEC_Msk,       /**< Last Error Code */
 318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_STATUS_TX_OK = CAN_NODE_NSR_TXOK_Msk,                /**< Message transmitted succes
 319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_STATUS_RX_OK = CAN_NODE_NSR_RXOK_Msk,                /**< Message received successfu
 320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_STATUS_ALERT_WARNING = CAN_NODE_NSR_ALERT_Msk,       /**< Alert warning */
 321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_STATUS_ERROR_WARNING_STATUS = CAN_NODE_NSR_EWRN_Msk, /**< Error warning status */
 322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_STATUS_BUS_OFF= CAN_NODE_NSR_BOFF_Msk,				/**< Bus-off status */
 323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_STATUS_LIST_LENGTH_ERROR = CAN_NODE_NSR_LLE_Msk,     /**< List length error */
 324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_STATUS_LIST_OBJECT_ERROR = CAN_NODE_NSR_LOE_Msk,     /**< List object error */
 325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #if !defined(MULTICAN_PLUS)
 326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_STATUS_SUSPENDED_ACK = CAN_NODE_NSR_SUSACK_Msk       /**< Suspend Acknowledge */
 327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #endif
 328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_NODE_STATUS_t;
 329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines mask value for CAN Node control like initialization, node disable and analyzer mode .
 332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Use type \a XMC_CAN_NODE_CONTROL_t for this enum.
 333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_NODE_CONTROL
 335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_CONTROL_NODE_INIT = CAN_NODE_NCR_INIT_Msk,            /**< Node initialization */
 337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_CONTROL_TX_INT_ENABLE = CAN_NODE_NCR_TRIE_Msk,        /**< Transfer event enable */
 338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_CONTROL_LEC_INT_ENABLE = CAN_NODE_NCR_LECIE_Msk,      /**< LEC Indicated Error Event
 339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_CONTROL_ALERT_INT_ENABLE = CAN_NODE_NCR_ALIE_Msk,     /**< Alert Event Enable */
 340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_CONTROL_CAN_DISABLE = CAN_NODE_NCR_CANDIS_Msk,        /**< CAN disable */
 341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_CONTROL_CONF_CHANGE_ENABLE= CAN_NODE_NCR_CCE_Msk,     /**< Configuration change enab
 342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_CONTROL_CAN_ANALYZER_NODEDE = CAN_NODE_NCR_CALM_Msk,  /**< CAN Analyzer mode */
 343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #if !defined(MULTICAN_PLUS)
 344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_CONTROL_SUSPENDED_ENABLE = CAN_NODE_NCR_SUSEN_Msk     /**< Suspend Enable */
 345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #endif
 346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_NODE_CONTROL_t;
 347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines mask value for CAN Node events. Use type \a XMC_CAN_NODE_EVENT_t for this enum.
 350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_NODE_EVENT
 352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_EVENT_TX_INT = CAN_NODE_NCR_TRIE_Msk,   /**< Node Transfer OK Event */
 354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_EVENT_ALERT = CAN_NODE_NCR_ALIE_Msk,    /**< Node Alert Event */
 355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_EVENT_LEC = CAN_NODE_NCR_LECIE_Msk,     /**< Last Error code Event */
 356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_EVENT_CFCIE = CAN_NODE_NFCR_CFCIE_Msk   /**< CAN Frame Count Event  */
 357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_NODE_EVENT_t;
 358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines mask value for CAN node pointer events position. Use type \a XMC_CAN_NODE_POINTER_EVENT_
 361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_NODE_POINTER_EVENT
 363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_POINTER_EVENT_ALERT = CAN_NODE_NIPR_ALINP_Pos,           /**< Node Alert Event node 
 365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_POINTER_EVENT_LEC = CAN_NODE_NIPR_LECINP_Pos,            /**< Last Error code Event 
 366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_POINTER_EVENT_TRANSFER_OK = CAN_NODE_NIPR_TRINP_Pos,     /**< Transmit Event node po
 367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_POINTER_EVENT_FRAME_COUNTER = CAN_NODE_NIPR_CFCINP_Pos   /**< CAN Frame Count Event 
 368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_NODE_POINTER_EVENT_t;
 369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines CAN Message Object event node pointer position. Use type \a XMC_CAN_MO_POINTER_EVENT_t f
 372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_MO_POINTER_EVENT
 374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_POINTER_EVENT_TRANSMIT = CAN_MO_MOIPR_TXINP_Pos,     /**< Transmit Event node pointer 
 376:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_POINTER_EVENT_RECEIVE = CAN_MO_MOIPR_RXINP_Pos       /**< Receive Event node pointer *
 377:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_MO_POINTER_EVENT_t;
 378:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 379:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 380:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines mask value for CAN Message Object event type. Use type \a XMC_CAN_MO_EVENT_t for this en
 381:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 382:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_MO_EVENT
 383:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 384:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_EVENT_TRANSMIT = CAN_MO_MOFCR_TXIE_Msk,  /**< Message Object transmit event */
 385:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_EVENT_RECEIVE = CAN_MO_MOFCR_RXIE_Msk,   /**< Message Object receive event */
 386:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_EVENT_OVERFLOW = CAN_MO_MOFCR_OVIE_Msk,  /**< Message Object overflow event */
 387:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_MO_EVENT_t;
 388:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 389:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 390:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines the possible receive inputs. Use type \a XMC_CAN_NODE_RECEIVE_INPUT_t for this enum.
 391:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 392:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_NODE_RECEIVE_INPUT
 393:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 394:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_RECEIVE_INPUT_RXDCA, 	/**< CAN Receive Input A */
 395:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_RECEIVE_INPUT_RXDCB,		/**< CAN Receive Input B */
 396:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_RECEIVE_INPUT_RXDCC,		/**< CAN Receive Input C */
 397:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_RECEIVE_INPUT_RXDCD,		/**< CAN Receive Input D */
 398:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_RECEIVE_INPUT_RXDCE,		/**< CAN Receive Input E */
 399:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_RECEIVE_INPUT_RXDCF,		/**< CAN Receive Input F */
 400:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_RECEIVE_INPUT_RXDCG,		/**< CAN Receive Input G */
 401:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_RECEIVE_INPUT_RXDCH		/**< CAN Receive Input H */
 402:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_NODE_RECEIVE_INPUT_t;
 403:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 404:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 405:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines last error transfer direction. Use type \a XMC_CAN_NODE_LAST_ERROR_DIR_t for this enum.
 406:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 407:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_NODE_LAST_ERROR_DIR
 408:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 409:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_LAST_ERROR_DIR_WHILE_NODE_RECEPCION,    /**< The last error occurred while the CAN n
 410:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_LAST_ERROR_DIR_WHILE_NODE_TRANSMISSION  /**< The last error occurred while the CAN n
 411:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_NODE_LAST_ERROR_DIR_t;
 412:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 413:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 414:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 415:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines last error increment. Use type \a XMC_CAN_NODE_LAST_ERROR_INC_t for this enum.
 416:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 417:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_NODE_LAST_ERROR_INC
 418:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 419:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_LAST_ERROR_INC_1, /**< The last error led to an error counter increment of 1. */
 420:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_LAST_ERROR_INC_8  /**< The last error led to an error counter increment of 8. */
 421:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_NODE_LAST_ERROR_INC_t;
 422:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 423:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 424:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines interrupt request on interrupt output line INT_O[n]. Use type \a XMC_CAN_NODE_INTERRUPT_
 425:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 426:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_NODE_INTERRUPT_TRIGGER
 427:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 428:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_INTR_TRIGGER_0 = 0x1U,
 429:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_INTR_TRIGGER_1 = 0x2U,
 430:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_INTR_TRIGGER_2 = 0x4U,
 431:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_INTR_TRIGGER_3 = 0x8U,
 432:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_INTR_TRIGGER_4 = 0x16U,
 433:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_INTR_TRIGGER_5 = 0x32U,
 434:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_INTR_TRIGGER_6 = 0x64U,
 435:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_INTR_TRIGGER_7 = 0x128U,
 436:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_NODE_INTERRUPT_TRIGGER_t;
 437:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 438:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #if defined(MULTICAN_PLUS) || defined(DOXYGEN)
 439:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 440:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines the Clock source used for the MCAN peripheral. @note Only available for XMC1400, XMC4800
 441:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 442:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef enum XMC_CAN_CANCLKSRC
 443:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 444:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #if UC_FAMILY == XMC4
 445:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_CANCLKSRC_FPERI = 0x1U,
 446:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_CANCLKSRC_FOHP = 0x2U,
 447:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #else
 448:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_CANCLKSRC_MCLK = 0x1U,
 449:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_CANCLKSRC_FOHP = 0x2U
 450:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #endif
 451:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_CANCLKSRC_t;
 452:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #endif
 453:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 454:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**************************************************************************************************
 455:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * DATA STRUCTURES
 456:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  **************************************************************************************************
 457:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 458:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines CAN node Nominal Bit Time. Use type \a XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t for this s
 459:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** */
 460:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef struct XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG
 461:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 462:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   uint32_t can_frequency;       /**< Frequency of the CAN module(fCAN). \a can_frequency shall be r
 463:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   uint32_t baudrate;        	/**< Specifies the node baud rate. Unit: baud \a baudrate shall be ran
 464:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   uint16_t sample_point;    	/**< Sample point is used to compensate mismatch between transmitter a
 465:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 									 the synchronization segment. Sample point. Range = [0, 10000] with respect [0%, 100%] of 
 466:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   uint16_t sjw;             	/**< (Re) Synchronization Jump Width. Range:0-3 */
 467:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t;
 468:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 469:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 470:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines base, top and bottom of CAN Message Object FIFO Structure. Use type \a XMC_CAN_FIFO_CONF
 471:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * A FIFO consists of one base object and n slave objects.
 472:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 473:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef struct XMC_CAN_FIFO_CONFIG
 474:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 475:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   uint8_t fifo_bottom;		/**< points to the first element(slave object) in a FIFO structure.Range :0
 476:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   uint8_t fifo_top;			/**< points to the last element(slave object) in a FIFO structure. Range :0-6
 477:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   uint8_t fifo_base;		/**< points to the actual target object(Base object) within a FIFO/Gateway st
 478:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_FIFO_CONFIG_t;
 479:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 480:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 481:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines CAN Gateway FIFO structure and provides additional options for gateway destination objec
 482:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Use type \a XMC_CAN_GATEWAY_CONFIG_t for this structure.
 483:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 484:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef struct XMC_CAN_GATEWAY_CONFIG
 485:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 486:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   uint8_t gateway_bottom; 			/**< points to the first element(gateway destination object) in a FIFO
 487:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   uint8_t gateway_top;				/**< points to the last element(gateway destination object) in a FIFO str
 488:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   uint8_t gateway_base;				/**< points to the actual target object within a FIFO/Gateway structure.
 489:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   bool gateway_data_frame_send;		/**< TXRQ updated in the gateway destination object after the inte
 490:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   	  	  	  	  	  	  	  	  	  	 to the gateway destination object */
 491:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   bool gateway_identifier_copy;		/**< The identifier of the gateway source object (after storing th
 492:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   	  	  	  	  	  	  	  	  	  	 to the gateway destination object. */
 493:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 494:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   bool gateway_data_length_code_copy; /**< Data length code of the gateway source object (after sto
 495:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   	  	  	  	  	  	  	  	  	  	   gateway destination object */
 496:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   bool gateway_data_copy;  /**< Data fields in registers MODATALn and MODATAHn of the gateway sourc
 497:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   	  	  	  	  	  	  	  	are copied to the gateway destination.*/
 498:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 499:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_GATEWAY_CONFIG_t;
 500:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 501:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 502:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** * Defines CAN Global Initialization structure
 503:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** */
 504:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef CAN_GLOBAL_TypeDef XMC_CAN_t;
 505:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 506:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /*Anonymous structure/union guard start*/
 507:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #if defined(__CC_ARM)
 508:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   #pragma push
 509:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   #pragma anon_unions
 510:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #elif defined(__TASKING__)
 511:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   #pragma warning 586
 512:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #endif
 513:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 514:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 515:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines frame counter configuration. Use type \a XMC_CAN_NODE_FRAME_COUNTER_t for this structure
 516:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * It provides configuration of frame counter that counts transmitted/received CAN frames or obtain
 517:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * when a frame has been started to transmit or be received by the CAN node.
 518:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** */
 519:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef struct XMC_CAN_NODE_FRAME_COUNTER
 520:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 521:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 522:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   union{
 523:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 	  struct{
 524:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		  uint32_t : 16;
 525:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		  uint32_t can_frame_count_selection:3;		/**<   Defines function of the frame counter  */
 526:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		  uint32_t can_frame_count_mode:2;			/**<   Determines the operation mode of the frame counter */
 527:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		  uint32_t : 11;
 528:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 	  };
 529:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 	  uint32_t nfcr;
 530:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 531:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   };
 532:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_NODE_FRAME_COUNTER_t;
 533:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 534:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 535:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *Defines Node Runtime structure.
 536:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** */
 537:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef CAN_NODE_TypeDef  XMC_CAN_NODE_t;            /**<  pointer to the Node CAN register */
 538:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 539:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 540:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Defines CAN Message Object runtime elements. Use type \a XMC_CAN_MO_t for this structure.
 541:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 542:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** typedef struct XMC_CAN_MO
 543:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 544:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 	CAN_MO_TypeDef *can_mo_ptr;                     /**< Pointer to the Message Object CAN register */
 545:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 	union{
 546:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		struct{
 547:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 			uint32_t can_identifier:29;            /**< standard (11 bit)/Extended (29 bit) message identifi
 548:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 			uint32_t can_id_mode:1;                /**< Standard/Extended identifier support */
 549:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 			uint32_t can_priority:2;               /**< Arbitration Mode/Priority */
 550:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		};
 551:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		uint32_t mo_ar;
 552:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 	};
 553:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 	union{
 554:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		struct{
 555:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 			uint32_t can_id_mask:29;              /**< CAN Identifier of Message Object */
 556:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 			uint32_t can_ide_mask:1;              /**< Identifier Extension Bit of Message Object */
 557:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		};
 558:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		uint32_t mo_amr;
 559:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 	};
 560:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   uint8_t can_data_length;                        /**< Message data length, Range:0-8 */
 561:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 562:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   union{
 563:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 564:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   		uint8_t can_data_byte[8];                 /**< Each position of the array represents a data byt
 565:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   		uint16_t can_data_word[4];                /**< Each position of the array represents a 16 bits 
 566:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   		uint32_t can_data[2];                     /**< can_data[0] lower 4 bytes of the data. can_data[
 567:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   		 	 	 	 	 	 	 	 	 	 	    of the data */
 568:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   		uint64_t can_data_long;                   /** Data of the Message Object*/
 569:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   	  };
 570:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 571:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_MO_TYPE_t can_mo_type;                  /**<  Message Type */
 572:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 573:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** } XMC_CAN_MO_t;
 574:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /*Anonymous structure/union guard end*/
 575:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #if defined(__CC_ARM)
 576:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   #pragma pop
 577:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #elif defined(__TASKING__)
 578:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   #pragma warning restore
 579:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #endif
 580:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**************************************************************************************************
 581:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * API Prototypes
 582:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  **************************************************************************************************
 583:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #ifdef __cplusplus
 584:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** extern "C" {
 585:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #endif
 586:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 587:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 588:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 589:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param obj	Pointer pointing to XMC_CAN Global Initialization structure. Defines CAN global regis
 590:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 				for details.
 591:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 592:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 593:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 594:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 595:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Disables CAN module. In disabled state, no registers of CAN module can be read or written excep
 596:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 597:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 598:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_Enable()\n\n\n
 599:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 600:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 601:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 602:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** void XMC_CAN_Disable(XMC_CAN_t *const obj);
 603:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 604:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 605:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 606:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param obj Pointer pointing to XMC_CAN Global Initialization structure. Defines CAN global regis
 607:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 			   for details.
 608:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 609:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 610:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 611:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 612:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Enables CAN module and initializes all CAN registers to reset values. It is required to re-conf
 613:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  before any data transfer. It configures CAN_CLC.DISR bit.
 614:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 615:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 616:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  XMC_CAN_Disable()\n\n\n
 617:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 618:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 619:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 620:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** void XMC_CAN_Enable(XMC_CAN_t *const obj);
 621:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 622:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 623:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 624:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param obj Pointer pointing to XMC_CAN Global Initialization structure. Defines CAN global regis
 625:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 		   for details.
 626:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 627:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param node_num	CAN node number,Range : 0-2
 628:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param mo_num 	CAN Message Object number,Range : 0-63
 629:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 630:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 631:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 632:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 633:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Allocates Message Object from free list to node list. Each \a node_num is linked to one unique 
 634:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  A CAN node performs message transfer only with the \a mo_num message objects that are allocated
 635:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  It configures PANCTR register.
 636:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 637:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 638:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  None
 639:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 640:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 641:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 642:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** void XMC_CAN_AllocateMOtoNodeList(XMC_CAN_t *const obj, const uint8_t node_num, const uint8_t mo_nu
 643:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 644:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 645:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 646:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param obj Pointer pointing to XMC_CAN Global Initialization structure. Defines CAN global regis
 647:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 			  for details.
 648:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 649:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param pancmd panal command selection. Refer @ref XMC_CAN_PANCMD_t for valid values.
 650:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param arg1	 Panel Argument 1,Range : 0-2
 651:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param arg2 	 Panel Argument 2, Range : 0-63
 652:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 653:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 654:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 655:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 656:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Configures the panel command and panel arguments. A panel operation consists of a command code 
 657:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  panel arguments (PANAR1, PANAR2). Commands that have a return value deliver it to the PANAR1 bi
 658:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  return an error flag deliver it to bit 31 of the Panel Control Register, this means bit 7 of PA
 659:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  panel argument PANAR1,\a arg2 represents panel argument PANAR2 and \a pancmd represents command
 660:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  register.
 661:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 662:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 663:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  None
 664:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 665:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 666:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 667:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_PanelControl(XMC_CAN_t *const obj,
 668:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****                                           const XMC_CAN_PANCMD_t pancmd,
 669:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		                                  const uint8_t arg1,
 670:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		                                  const uint8_t arg2)
 671:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 672:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   obj->PANCTR = (((uint32_t)pancmd << CAN_PANCTR_PANCMD_Pos) & (uint32_t)CAN_PANCTR_PANCMD_Msk) |
 673:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		        (((uint32_t)arg1 << CAN_PANCTR_PANAR1_Pos) & (uint32_t)CAN_PANCTR_PANAR1_Msk) |
 674:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		        (((uint32_t)arg2 << CAN_PANCTR_PANAR2_Pos) & (uint32_t)CAN_PANCTR_PANAR2_Msk);
 675:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 676:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 677:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 678:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 679:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 680:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param obj Pointer pointing to XMC_CAN Global Initialization structure. Defines CAN global regis
 681:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 			  for details.
 682:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 683:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param service_requestr	Interrupt trigger number selection. Refer @ref XMC_CAN_NODE_INTERRUPT_TR
 684:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 							 Multiple interrupt trigger events can be ORed.
 685:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 686:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 687:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 688:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 689:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Configures multiple interrupt requests with a single write operation. \a service_requestr repre
 690:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  request or multiple.It configures MITR register.
 691:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 692:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 693:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  None
 694:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 695:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 696:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 697:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_EventTrigger(XMC_CAN_t *const obj,const XMC_CAN_NODE_INTERRUPT_TRIGGER
 698:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 699:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   obj->MITR = ((uint32_t)service_requestr << CAN_MITR_IT_Pos) & (uint32_t)CAN_MITR_IT_Msk;
 700:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 701:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 702:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 703:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 704:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 								/*INIT APIs*/
 705:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 706:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 707:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 708:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param obj Pointer pointing to XMC_CAN Global Initialization structure. Defines CAN global regis
 709:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 			  for details.
 710:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 711:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_frequency	CAN module frequency(fCAN). Range : 5MHz to 120MHz
 712:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 713:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 714:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 715:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 716:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Configures clock rate of the module timer clock fCAN. Altering CAN module \a can_frequency shall
 717:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * call XMC_CAN_NODE_NominalBitTimeConfigure() to configure baud rate for current CAN frequency.It 
 718:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 719:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 720:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_NominalBitTimeConfigure()\n\n\n
 721:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 722:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 723:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 724:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 725:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #if defined(MULTICAN_PLUS)
 726:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** void XMC_CAN_Init(XMC_CAN_t *const obj, XMC_CAN_CANCLKSRC_t clksrc, uint32_t can_frequency);
 727:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 728:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 729:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 730:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** XMC_CAN_CANCLKSRC_t XMC_CAN_GetBaudrateClockSource(XMC_CAN_t *const obj);
 731:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 732:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 733:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 734:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** void XMC_CAN_SetBaudrateClockSource(XMC_CAN_t *const obj,const XMC_CAN_CANCLKSRC_t source);
 735:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 736:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 737:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 738:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** uint32_t XMC_CAN_GetBaudrateClockFrequency(XMC_CAN_t *const obj);
 739:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #else
 740:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** void XMC_CAN_Init(XMC_CAN_t *const obj, uint32_t can_frequency);
 741:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #endif
 742:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 743:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 744:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 745:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_mo Pointer to Message Object structure. Refer @ref XMC_CAN_MO_t data structure for de
 746:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 747:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 748:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 749:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 750:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Initializes CAN message object. Initialization includes configuring Message Object identifier ty
 751:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * identifier value, Message Object type, and transfer requests. It configures FDR register.
 752:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 753:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 754:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
 755:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 756:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 757:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 758:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** void XMC_CAN_MO_Config(const XMC_CAN_MO_t *const can_mo);
 759:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 760:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 761:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 	  /*NODE APIs*/
 762:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 763:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 764:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 765:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 766:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node  	  Pointer pointing to CAN_NODE Structure. Defines CAN_NODE registers.
 767:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param ptr_event		  CAN_NODE interrupt pointer position. Refer @ref XMC_CAN_NODE_POINTER_EVENT_t
 768:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param service_request Interrupt service request number. Range : 0-7
 769:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 770:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 771:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 772:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 773:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Configures node interrupt pointer \a service_request for CAN Node events \a ptr_event. It confi
 774:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 775:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 776:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
 777:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 778:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 779:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 780:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_SetEventNodePointer(XMC_CAN_NODE_t *const can_node,
 781:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		                                      const XMC_CAN_NODE_POINTER_EVENT_t ptr_event,
 782:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		                                      const uint32_t service_request)
 783:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 784:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NIPR = (uint32_t)((can_node->NIPR) & ~(uint32_t)(CAN_NODE_NIPR_Msk << (uint32_t)ptr_eve
 785:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 786:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 787:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 788:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 789:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 790:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node		Pointer pointing to CAN_NODE Structure. Defines CAN_NODE registers. Range :CAN_
 791:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_bit_time	Nominal bit time configuration data structure. Refer @ref XMC_CAN_NODE_NOMIN
 792:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 793:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 794:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 795:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 796:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Configures CAN node Baudrate. \a can_bit_time specifies required baudrate for a specified \a can
 797:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * It configures NBTR register.
 798:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 799:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 800:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
 801:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 802:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 803:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** void XMC_CAN_NODE_NominalBitTimeConfigure (XMC_CAN_NODE_t *const can_node,
 804:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****                                            const XMC_CAN_NODE_NOMINAL_BIT_TIME_CONFIG_t *const can_
 805:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 806:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 807:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
 808:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param input    CAN receive input selection. Refer @ref XMC_CAN_NODE_RECEIVE_INPUT_t for details
 809:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 810:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 811:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 812:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 813:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \a input specifies CAN input receive pin. This API Configures NPCRx register,it is required to c
 814:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_EnableConfigurationChange(), before configuring NPCRx register, call XMC_CAN_NODE_D
 815:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * API after configuring NPCRx register. CAN input receive pins which falls under analog port pins 
 816:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_GPIO_EnableDigitalInput(),to enable digital pad.
 817:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 818:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *\par<b>Related APIs:</b><BR>
 819:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
 820:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 821:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Note:</b><br>
 822:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * NPCRx can be written only if bit NCRx.CCE is set.
 823:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 824:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 825:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 826:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_SetReceiveInput(XMC_CAN_NODE_t *const can_node,
 827:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		                                          const XMC_CAN_NODE_RECEIVE_INPUT_t input)
 828:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 829:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NPCR = ((can_node->NPCR) & ~(uint32_t)(CAN_NODE_NPCR_RXSEL_Msk)) |
 830:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****                    (((uint32_t)input << CAN_NODE_NPCR_RXSEL_Pos) & (uint32_t)CAN_NODE_NPCR_RXSEL_Ms
 831:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 832:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 833:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 834:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 835:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node	Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
 836:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 837:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 838:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 839:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 840:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Enable Node \a can_node in Loop-Back Mode. A Node is connected to an internal (virtual) loop-bac
 841:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * nodes which are in Loop- Back Mode are connected to this virtual CAN bus so that they can commun
 842:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * other internally. The external transmit line is forced recessive in Loop-Back Mode. This API Con
 843:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * call XMC_CAN_NODE_EnableConfigurationChange() API before NPCRx configuration, same way XMC_CAN_N
 844:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * API after NPCRx configuration configuration.
 845:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 846:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>]
 847:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  XMC_CAN_NODE_DisableLoopBack().
 848:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 849:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  \par<b>Note:</b><br>
 850:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  NPCRx can be written only if bit NCRx.CCE is set.
 851:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 852:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 853:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 854:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_EnableLoopBack(XMC_CAN_NODE_t *const can_node)
 855:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 856:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NPCR |= (uint32_t)CAN_NODE_NPCR_LBM_Msk;
 857:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 858:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 859:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 860:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 861:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
 862:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 863:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 864:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 865:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 866:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Disable Node Loop-Back Mode, disables internal (virtual) loop-back CAN bus. This API Configures 
 867:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Call XMC_CAN_NODE_EnableConfigurationChange() API before NPCRx configuration, same way XMC_CAN_N
 868:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * API after NPCRx configuration.
 869:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 870:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>]
 871:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_EnableLoopBack()
 872:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 873:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 874:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Note:</b><br>
 875:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * NPCRx can be written only if bit NCRx.CCE is set.
 876:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 877:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 878:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 879:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_DisableLoopBack(XMC_CAN_NODE_t *const can_node)
 880:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 881:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NPCR &= ~(uint32_t)CAN_NODE_NPCR_LBM_Msk;
 882:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 883:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 884:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 885:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 886:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 887:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
 888:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param event	   CAN node event mask value. Refer @ref XMC_CAN_NODE_EVENT_t structure for valid v
 889:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 				   multiple events can be ORed.
 890:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 891:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 892:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 893:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 894:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Enable CAN Node events. It configures NFCR register.
 895:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 896:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 897:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_DisableEvent()
 898:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 899:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 900:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 901:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** void XMC_CAN_NODE_EnableEvent(XMC_CAN_NODE_t *const can_node, const XMC_CAN_NODE_EVENT_t event);
 902:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 903:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 904:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 905:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 906:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
 907:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param event	   CAN node event mask value. Refer @ref XMC_CAN_NODE_EVENT_t structure for valid v
 908:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 				   multiple events can be ORed.
 909:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 910:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 911:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 912:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 913:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Disable CAN Node events. It configures NFCR register.
 914:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 915:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 916:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_EnableEvent()
 917:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 918:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 919:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 920:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** void XMC_CAN_NODE_DisableEvent(XMC_CAN_NODE_t *const can_node, const XMC_CAN_NODE_EVENT_t event);
 921:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 922:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 923:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 924:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 925:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_NODE0
 926:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 927:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return XMC_CAN_NODE_LAST_ERROR_DIR_t Last error transfer direction. Refer @ref XMC_CAN_NODE_LAS
 928:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 929:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 930:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Returns NODE Last Error occurred during Transmit/receive direction. It returns value of NFCR reg
 931:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 932:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 933:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_GetLastErrTransferInc()\n\n\n
 934:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 935:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 936:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 937:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE XMC_CAN_NODE_LAST_ERROR_DIR_t XMC_CAN_NODE_GetLastErrTransferDir(XMC_CAN_NODE_t *co
 938:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 939:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   return (XMC_CAN_NODE_LAST_ERROR_DIR_t)(((node->NECNT) & CAN_NODE_NECNT_LETD_Msk) >> CAN_NODE_NECN
 940:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 941:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 942:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 943:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 944:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 945:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_NODE0
 946:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 947:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return XMC_CAN_NODE_LAST_ERROR_INC_t Last error transfer increment. Refer @ref XMC_CAN_NODE_LAS
 948:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 949:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 950:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Returns NODE Last Error Transfer Increment. It returns value of NFCR register.
 951:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 952:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 953:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_GetLastErrTransferDir()\n\n\n
 954:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 955:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 956:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 957:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE XMC_CAN_NODE_LAST_ERROR_INC_t XMC_CAN_NODE_GetLastErrTransferInc(XMC_CAN_NODE_t *co
 958:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 959:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   return (XMC_CAN_NODE_LAST_ERROR_INC_t)(((node->NECNT) & CAN_NODE_NECNT_LEINC_Msk)>> CAN_NODE_NECN
 960:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 961:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 962:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 963:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 964:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 965:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
 966:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param  error_warning_level	Error Warning level value. Range :0-255.
 967:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 968:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 969:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 970:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 971:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Configures error warning level in order to set the corresponding error warning bit EWRN. It conf
 972:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * into NECNT register. Before this configuration call XMC_CAN_NODE_EnableConfigurationChange() API
 973:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 974:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
 975:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_GetErrorWarningLevel()\n\n\n
 976:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 977:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Note:</b><br>
 978:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  NECNTx can be written only if bit NCRx.CCE is set.
 979:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 980:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
 981:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 982:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_SetErrorWarningLevel(XMC_CAN_NODE_t *const can_node, uint8_t erro
 983:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 984:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NECNT = ((can_node->NECNT) & ~(uint32_t)(CAN_NODE_NECNT_EWRNLVL_Msk)) |
 985:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****                     (((uint32_t)error_warning_level << CAN_NODE_NECNT_EWRNLVL_Pos) & (uint32_t)CAN_
 986:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 987:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 988:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
 989:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
 990:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 991:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
 992:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_tec  transmit error counter value. Range :0-255
 993:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 994:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
 995:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
 996:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
 997:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Configures Transmit error counter. It configures \a can_tec into NECNT register. Before this co
 998:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  XMC_CAN_NODE_EnableConfigurationChange() API.
 999:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1000:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
1001:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_GetTransmitErrorCounter()\n\n\n
1002:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1003:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  \par<b>Note:</b><br>
1004:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  NECNTx can be written only if bit NCRx.CCE is set.
1005:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1006:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1007:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1008:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1009:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_SetTransmitErrorCounter(XMC_CAN_NODE_t *const can_node, uint8_t c
1010:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1011:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NECNT = ((can_node->NECNT) & ~(uint32_t)(CAN_NODE_NECNT_TEC_Msk)) |
1012:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****                     (((uint32_t)can_tec << CAN_NODE_NECNT_TEC_Pos) & (uint32_t)CAN_NODE_NECNT_TEC_M
1013:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1014:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1015:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1016:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1017:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1018:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1019:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_rec  receive error counter value. Range :0-255
1020:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1021:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1022:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1023:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1024:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Configures Receive Error Counter. It configures \a can_rec into NECNT register. Before this conf
1025:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_EnableConfigurationChange() API.
1026:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1027:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
1028:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_GetReceiveErrorCounter()\n\n\n
1029:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1030:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Note:</b><br>
1031:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  NECNTx can be written only if bit NCRx.CCE is set.
1032:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1033:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1034:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1035:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_SetReceiveErrorCounter(XMC_CAN_NODE_t *const can_node, uint8_t ca
1036:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1037:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  can_node->NECNT = ((can_node->NECNT) & ~(uint32_t)(CAN_NODE_NECNT_REC_Msk)) |
1038:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****                    (((uint32_t)can_rec << CAN_NODE_NECNT_REC_Pos) & (uint32_t)CAN_NODE_NECNT_REC_Ms
1039:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1040:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1041:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1042:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1043:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1044:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1045:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1046:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return uint8_t Error Warning Level. Range :0 - 255
1047:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1048:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1049:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *	Returns error warning level. This determines the threshold value (warning level, default 96) to 
1050:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *	to set the corresponding error warning bit EWRN. It reads NECNT register.
1051:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1052:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
1053:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_SetErrorWarningLevel()\n\n\n
1054:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1055:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1056:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1057:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1058:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE uint8_t XMC_CAN_NODE_GetErrorWarningLevel(XMC_CAN_NODE_t *const can_node)
1059:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1060:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  return (uint8_t)((uint32_t)((can_node->NECNT)  & CAN_NODE_NECNT_EWRNLVL_Msk) >> CAN_NODE_NECNT_EWR
1061:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1062:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1063:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1064:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1065:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1066:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1067:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1068:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return uint8_t transmit error counter value. Range :0 - 255
1069:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1070:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1071:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *	Returns Transmit Error Counter value. If the Bitstream Processor detects an error while a transm
1072:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *	running, the Transmit Error Counter is incremented by 8. An increment of 1 is used when the erro
1073:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *	reported by an external CAN node via an Error Frame generation. It reads NECNT register.
1074:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1075:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
1076:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_SetTransmitErrorCounter()
1077:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1078:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Note:</b><br>
1079:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  NECNTx can be written only if bit NCRx.CCE is set.
1080:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1081:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1082:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1083:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE uint8_t XMC_CAN_NODE_GetTransmitErrorCounter(XMC_CAN_NODE_t *const can_node)
1084:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1085:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   return (uint8_t)((uint32_t)((can_node->NECNT)  & CAN_NODE_NECNT_TEC_Msk) >> CAN_NODE_NECNT_TEC_Po
1086:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1087:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1088:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1089:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1090:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1091:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1092:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1093:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return uint8_t	receive error counter value.
1094:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1095:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1096:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *	Returns Receive Error Counter value. It reads NECNT register.
1097:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1098:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
1099:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_SetReceiveErrorCounter()
1100:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1101:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1102:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1103:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE uint8_t XMC_CAN_NODE_GetReceiveErrorCounter(XMC_CAN_NODE_t *const can_node)
1104:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1105:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   return (uint8_t)((uint32_t)((can_node->NECNT)  & CAN_NODE_NECNT_REC_Msk) >> CAN_NODE_NECNT_REC_Po
1106:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1107:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1108:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1109:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1110:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1111:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1112:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1113:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return uint32_t Current status of the node.
1114:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1115:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1116:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Returns errors status as well as successfully transferred CAN frames status.
1117:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1118:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
1119:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  XMC_CAN_NODE_ClearStatus()
1120:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1121:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1122:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1123:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE uint32_t XMC_CAN_NODE_GetStatus(XMC_CAN_NODE_t *const can_node)
1124:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1125:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   return ((can_node->NSR));
1126:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1127:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1128:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1129:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1130:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1131:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node_status Status to clear.Refer @ref XMC_CAN_NODE_STATUS_t for valid values.
1132:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1133:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1134:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1135:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1136:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Clear errors status as well as successfully transferred CAN frames status.
1137:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1138:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
1139:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_GetStatus()
1140:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1141:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1142:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1143:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_ClearStatus(XMC_CAN_NODE_t *const can_node,XMC_CAN_NODE_STATUS_t 
1144:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1145:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****    can_node->NSR &= ~(uint32_t)can_node_status;
1146:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1147:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1148:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1149:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1150:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1151:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1152:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1153:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1154:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1155:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1156:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Allow to change the configuration of the CAN node, like bit timing, CAN bus transmit/receive por
1157:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * counters read. It configures NCRx.CCE bit.
1158:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1159:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related APIs:</b><BR>
1160:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_DisableConfigurationChange()
1161:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1162:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1163:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1164:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_EnableConfigurationChange(XMC_CAN_NODE_t *const can_node)
1165:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1166:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NCR |= (uint32_t)CAN_NODE_NCR_CCE_Msk;
1167:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1168:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1169:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1170:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1171:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1172:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1173:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1174:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1175:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1176:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1177:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *	Forbid to change the configuration of the CAN node. It configures NCRx.CCE bit.
1178:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1179:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1180:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_EnableConfigurationChange()
1181:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1182:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1183:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1184:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_DisableConfigurationChange(XMC_CAN_NODE_t *const can_node)
1185:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1186:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CCE_Msk;
1187:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1188:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1189:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1190:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1191:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1192:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1193:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1194:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1195:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1196:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1197:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1198:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Disable CAN node participation in CAN traffic. Bit INIT is automatically set when the CAN node e
1199:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * state. It configures NCR.INIT bit.
1200:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1201:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1202:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_ResetInitBit()
1203:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1204:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1205:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1206:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_SetInitBit(XMC_CAN_NODE_t *const can_node)
1207:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 221              	 .loc 2 1207 0
 222              	 .cfi_startproc
 223              	 
 224              	 
 225              	 
 226 0000 80B4     	 push {r7}
 227              	.LCFI24:
 228              	 .cfi_def_cfa_offset 4
 229              	 .cfi_offset 7,-4
 230 0002 83B0     	 sub sp,sp,#12
 231              	.LCFI25:
 232              	 .cfi_def_cfa_offset 16
 233 0004 00AF     	 add r7,sp,#0
 234              	.LCFI26:
 235              	 .cfi_def_cfa_register 7
 236 0006 7860     	 str r0,[r7,#4]
1208:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NCR |= (uint32_t)CAN_NODE_NCR_INIT_Msk;
 237              	 .loc 2 1208 0
 238 0008 7B68     	 ldr r3,[r7,#4]
 239 000a 1B68     	 ldr r3,[r3]
 240 000c 43F00102 	 orr r2,r3,#1
 241 0010 7B68     	 ldr r3,[r7,#4]
 242 0012 1A60     	 str r2,[r3]
1209:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 243              	 .loc 2 1209 0
 244 0014 0C37     	 adds r7,r7,#12
 245              	.LCFI27:
 246              	 .cfi_def_cfa_offset 4
 247 0016 BD46     	 mov sp,r7
 248              	.LCFI28:
 249              	 .cfi_def_cfa_register 13
 250              	 
 251 0018 5DF8047B 	 ldr r7,[sp],#4
 252              	.LCFI29:
 253              	 .cfi_restore 7
 254              	 .cfi_def_cfa_offset 0
 255 001c 7047     	 bx lr
 256              	 .cfi_endproc
 257              	.LFE199:
 259 001e 00BF     	 .section .text.XMC_CAN_NODE_ResetInitBit,"ax",%progbits
 260              	 .align 2
 261              	 .thumb
 262              	 .thumb_func
 264              	XMC_CAN_NODE_ResetInitBit:
 265              	.LFB200:
1210:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1211:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1212:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1213:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1214:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1215:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1216:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1217:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1218:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Enable CAN node participation in CAN traffic. Bit INIT is automatically set when the CAN node en
1219:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * state. It configures NCR.INIT bit.
1220:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1221:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1222:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_SetInitBit()
1223:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1224:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1225:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_ResetInitBit(XMC_CAN_NODE_t *const can_node)
1226:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 266              	 .loc 2 1226 0
 267              	 .cfi_startproc
 268              	 
 269              	 
 270              	 
 271 0000 80B4     	 push {r7}
 272              	.LCFI30:
 273              	 .cfi_def_cfa_offset 4
 274              	 .cfi_offset 7,-4
 275 0002 83B0     	 sub sp,sp,#12
 276              	.LCFI31:
 277              	 .cfi_def_cfa_offset 16
 278 0004 00AF     	 add r7,sp,#0
 279              	.LCFI32:
 280              	 .cfi_def_cfa_register 7
 281 0006 7860     	 str r0,[r7,#4]
1227:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_INIT_Msk;
 282              	 .loc 2 1227 0
 283 0008 7B68     	 ldr r3,[r7,#4]
 284 000a 1B68     	 ldr r3,[r3]
 285 000c 23F00102 	 bic r2,r3,#1
 286 0010 7B68     	 ldr r3,[r7,#4]
 287 0012 1A60     	 str r2,[r3]
1228:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 288              	 .loc 2 1228 0
 289 0014 0C37     	 adds r7,r7,#12
 290              	.LCFI33:
 291              	 .cfi_def_cfa_offset 4
 292 0016 BD46     	 mov sp,r7
 293              	.LCFI34:
 294              	 .cfi_def_cfa_register 13
 295              	 
 296 0018 5DF8047B 	 ldr r7,[sp],#4
 297              	.LCFI35:
 298              	 .cfi_restore 7
 299              	 .cfi_def_cfa_offset 0
 300 001c 7047     	 bx lr
 301              	 .cfi_endproc
 302              	.LFE200:
 304 001e 00BF     	 .section .text.XMC_CAN_NODE_SetAnalyzerMode,"ax",%progbits
 305              	 .align 2
 306              	 .thumb
 307              	 .thumb_func
 309              	XMC_CAN_NODE_SetAnalyzerMode:
 310              	.LFB203:
1229:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1230:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1231:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1232:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1233:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1234:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1235:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1236:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1237:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Enable the CAN node, starts the participation in CAN traffic. It configures NCR.CANDIS and the N
1238:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1239:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1240:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
1241:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1242:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1243:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_Enable(XMC_CAN_NODE_t *const can_node)
1244:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1245:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CANDIS_Msk;
1246:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   XMC_CAN_NODE_ResetInitBit(can_node);
1247:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1248:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1249:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1250:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1251:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1252:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1253:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1254:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1255:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1256:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Disable the CAN node, terminates participation in CAN traffic. It configures NCR.CANDIS bit.
1257:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1258:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1259:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
1260:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1261:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1262:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_Disable(XMC_CAN_NODE_t *const can_node)
1263:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1264:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NCR |= (uint32_t)CAN_NODE_NCR_CANDIS_Msk;
1265:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1266:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1267:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1268:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1269:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1270:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1271:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1272:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1273:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Configure CAN node in Analyzer Mode. This means that messages may be received, but not transmitt
1274:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * is sent on the CAN bus upon frame reception. Active-error flags are sent recessive instead of do
1275:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * The transmit line is continuously held at recessive (1) level. XMC_CAN_NODE_SetInitBit() should 
1276:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * set / reset AnalyzerMode. It configures NCR.CALM bit.
1277:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1278:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1279:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_ReSetAnalyzerMode()
1280:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1281:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1282:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1283:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1284:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_SetAnalyzerMode(XMC_CAN_NODE_t *const can_node)
1285:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 311              	 .loc 2 1285 0
 312              	 .cfi_startproc
 313              	 
 314              	 
 315              	 
 316 0000 80B4     	 push {r7}
 317              	.LCFI36:
 318              	 .cfi_def_cfa_offset 4
 319              	 .cfi_offset 7,-4
 320 0002 83B0     	 sub sp,sp,#12
 321              	.LCFI37:
 322              	 .cfi_def_cfa_offset 16
 323 0004 00AF     	 add r7,sp,#0
 324              	.LCFI38:
 325              	 .cfi_def_cfa_register 7
 326 0006 7860     	 str r0,[r7,#4]
1286:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NCR |= (uint32_t)CAN_NODE_NCR_CALM_Msk;
 327              	 .loc 2 1286 0
 328 0008 7B68     	 ldr r3,[r7,#4]
 329 000a 1B68     	 ldr r3,[r3]
 330 000c 43F08002 	 orr r2,r3,#128
 331 0010 7B68     	 ldr r3,[r7,#4]
 332 0012 1A60     	 str r2,[r3]
1287:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 333              	 .loc 2 1287 0
 334 0014 0C37     	 adds r7,r7,#12
 335              	.LCFI39:
 336              	 .cfi_def_cfa_offset 4
 337 0016 BD46     	 mov sp,r7
 338              	.LCFI40:
 339              	 .cfi_def_cfa_register 13
 340              	 
 341 0018 5DF8047B 	 ldr r7,[sp],#4
 342              	.LCFI41:
 343              	 .cfi_restore 7
 344              	 .cfi_def_cfa_offset 0
 345 001c 7047     	 bx lr
 346              	 .cfi_endproc
 347              	.LFE203:
 349 001e 00BF     	 .section .text.XMC_CAN_NODE_ReSetAnalyzerMode,"ax",%progbits
 350              	 .align 2
 351              	 .thumb
 352              	 .thumb_func
 354              	XMC_CAN_NODE_ReSetAnalyzerMode:
 355              	.LFB204:
1288:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1289:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1290:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1291:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1292:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1293:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1294:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1295:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1296:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Reset the Analyzer mode. CAN node is no more in Analyzer Mode. Please refer XMC_CAN_NODE_SetAnal
1297:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * It configures NCR.CALM bit. XMC_CAN_NODE_SetInitBit() should be called before set / reset Analyz
1298:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1299:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1300:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_NODE_SetAnalyzerMode()
1301:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1302:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1303:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1304:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_ReSetAnalyzerMode(XMC_CAN_NODE_t *const can_node)
1305:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 356              	 .loc 2 1305 0
 357              	 .cfi_startproc
 358              	 
 359              	 
 360              	 
 361 0000 80B4     	 push {r7}
 362              	.LCFI42:
 363              	 .cfi_def_cfa_offset 4
 364              	 .cfi_offset 7,-4
 365 0002 83B0     	 sub sp,sp,#12
 366              	.LCFI43:
 367              	 .cfi_def_cfa_offset 16
 368 0004 00AF     	 add r7,sp,#0
 369              	.LCFI44:
 370              	 .cfi_def_cfa_register 7
 371 0006 7860     	 str r0,[r7,#4]
1306:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NCR &= ~(uint32_t)CAN_NODE_NCR_CALM_Msk;
 372              	 .loc 2 1306 0
 373 0008 7B68     	 ldr r3,[r7,#4]
 374 000a 1B68     	 ldr r3,[r3]
 375 000c 23F08002 	 bic r2,r3,#128
 376 0010 7B68     	 ldr r3,[r7,#4]
 377 0012 1A60     	 str r2,[r3]
1307:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 378              	 .loc 2 1307 0
 379 0014 0C37     	 adds r7,r7,#12
 380              	.LCFI45:
 381              	 .cfi_def_cfa_offset 4
 382 0016 BD46     	 mov sp,r7
 383              	.LCFI46:
 384              	 .cfi_def_cfa_register 13
 385              	 
 386 0018 5DF8047B 	 ldr r7,[sp],#4
 387              	.LCFI47:
 388              	 .cfi_restore 7
 389              	 .cfi_def_cfa_offset 0
 390 001c 7047     	 bx lr
 391              	 .cfi_endproc
 392              	.LFE204:
 394 001e 00BF     	 .section .text.XMC_CAN_MO_GetStatus,"ax",%progbits
 395              	 .align 2
 396              	 .thumb
 397              	 .thumb_func
 399              	XMC_CAN_MO_GetStatus:
 400              	.LFB209:
1308:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1309:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #if !defined(MULTICAN_PLUS)
1310:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1311:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1312:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1313:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1314:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1315:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1316:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Trigger the suspension of the CAN node. An OCDS(on chip debug support) suspend trigger disables 
1317:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * soon as the CAN node becomes bus-idle or bus-off, bit INIT is internally forced to 1 to disable 
1318:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * The actual value of bit INIT remains unchanged. It configures NCR.SUSEN bit
1319:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1320:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1321:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
1322:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1323:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *\par<b>Note:</b><br>
1324:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Bit SUSEN is reset via OCDS(on chip debug support) Reset.
1325:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1326:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1327:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1328:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_EnableSuspend(XMC_CAN_NODE_t *const can_node)
1329:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1330:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NCR |= (uint32_t)CAN_NODE_NCR_SUSEN_Msk;
1331:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1332:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #else
1333:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1334:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1335:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1336:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1337:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1338:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1339:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Disables the transmission on CAN node x as soon as bus-idle is reached.
1340:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1341:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1342:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
1343:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1344:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @note Only available for XMC1400,XMC4800 and XMC4700 series
1345:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1346:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1347:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_DisableTransmit(XMC_CAN_NODE_t *const can_node)
1348:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1349:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NCR |= (uint32_t)CAN_NODE_NCR_TXDIS_Msk;
1350:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1351:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** #endif
1352:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1353:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1354:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1355:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1356:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1357:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node_init	frame counter mode selection. Refer @ref XMC_CAN_NODE_FRAME_COUNTER_t for v
1358:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1359:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1360:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1361:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1362:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Configures frame counter functions. Each CAN \a can_node is equipped with a frame counter that c
1363:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * CAN frames or obtains information about the time when a frame has been started to transmit or be
1364:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * node. It configures NFCR register.
1365:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1366:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1367:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
1368:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1369:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1370:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1371:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_NODE_FrameCounterConfigure(XMC_CAN_NODE_t *const can_node,
1372:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****                                         const XMC_CAN_NODE_FRAME_COUNTER_t *const can_node_init)
1373:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1374:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_node->NFCR = (can_node->NFCR & ~(uint32_t)(CAN_NODE_NFCR_CFMOD_Msk |
1375:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****                                        CAN_NODE_NFCR_CFSEL_Msk)) |
1376:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****                     can_node_init->nfcr;
1377:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1378:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1379:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1380:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1381:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1382:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_node Pointer Pointing to CAN_NODE Structure. Defines CAN_NODE registers, Range :CAN_N
1383:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1384:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return uint16_t	current value of the CAN frame counter. Range :0-65535
1385:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1386:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1387:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Returns the frame counter value \a can_node of the CAN node. In Frame Count Mode (CFMOD = 00B),
1388:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  count value. In Time Stamp Mode (CFMOD = 01B), this API returns the captured bit time count val
1389:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  the start of a new frame. In all Bit Timing Analysis Modes (CFMOD = 10B), this API always retur
1390:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  fCLC clock cycles (measurement result) minus 1.
1391:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1392:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1393:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
1394:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1395:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1396:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1397:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE uint16_t XMC_CAN_NODE_GetCANFrameCounter(XMC_CAN_NODE_t *const can_node)
1398:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1399:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   return (uint16_t)(((uint32_t)(can_node->NFCR & CAN_NODE_NFCR_CFC_Msk) >> CAN_NODE_NFCR_CFC_Pos));
1400:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1401:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1402:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****                                      /*MO APIs*/
1403:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1404:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1405:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1406:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_mo Pointer to Message Object structure. Refer @ref XMC_CAN_MO_t data structure for de
1407:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1408:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return XMC_CAN_STATUS_t	CAN Node status. Refer @ref XMC_CAN_STATUS_t structure for details.
1409:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1410:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1411:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1412:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1413:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Configures Data to be transmitted and data length code.
1414:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1415:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1416:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_MO_Config()\n\n\n
1417:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1418:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1419:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1420:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1421:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** XMC_CAN_STATUS_t XMC_CAN_MO_UpdateData(const XMC_CAN_MO_t *const can_mo);
1422:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1423:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1424:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1425:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_mo Pointer to Message Object structure. Refer @ref XMC_CAN_MO_t data structure for de
1426:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1427:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return XMC_CAN_STATUS_t	CAN Node status. Refer @ref XMC_CAN_STATUS_t structure for details.
1428:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1429:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1430:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Configures transmit request for sending data frame. It configures MOCTR register. Data shall be
1431:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  using XMC_CAN_MO_UpdateData() before calling this API.
1432:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1433:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1434:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * XMC_CAN_MO_UpdateData()\n\n\n
1435:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1436:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1437:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1438:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** XMC_CAN_STATUS_t XMC_CAN_MO_Transmit(const XMC_CAN_MO_t *const can_mo);
1439:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1440:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1441:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1442:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_mo Pointer to Message Object structure. Refer @ref XMC_CAN_MO_t data structure for de
1443:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1444:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return XMC_CAN_STATUS_t	CAN Node status. Refer @ref XMC_CAN_STATUS_t structure for details.
1445:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1446:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1447:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Reads the Message Object data bytes, into message pointer passed as input parameter \a can_mo.
1448:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  can_data[0] of can_mo holds lower 4 bytes, can_data[1] of can_mo holds higher 4 bytes.
1449:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1450:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1451:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
1452:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1453:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1454:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1455:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** XMC_CAN_STATUS_t XMC_CAN_MO_Receive(XMC_CAN_MO_t *can_mo);
1456:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1457:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1458:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1459:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_mo Pointer to Message Object structure. Refer @ref XMC_CAN_MO_t data structure for de
1460:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1461:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return XMC_CAN_STATUS_t	CAN Node status. Refer @ref XMC_CAN_STATUS_t structure for details.
1462:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1463:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1464:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Reads the Message Object data bytes, into message pointer passed as input parameter \a can_mo.
1465:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  can_data[0] of can_mo holds lower 4 bytes, can_data[1] of can_mo holds higher 4 bytes.
1466:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1467:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1468:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
1469:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1470:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1471:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** XMC_CAN_STATUS_t XMC_CAN_MO_ReceiveData (XMC_CAN_MO_t *can_mo);
1472:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1473:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_mo 		 	 Pointer to Message Object structure. Refer @ref XMC_CAN_MO_t data structure f
1474:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_mo_ptr_int 	 Message Object event node pointer selection. Refer @ref XMC_CAN_MO_POINT
1475:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * 					 	    for valid values.
1476:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param service_request	interrupt output line of multiCAN module.
1477:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1478:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return None
1479:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1480:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1481:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * Configures Message Object event node pointer with \a service_request number. It configures MOIPR
1482:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1483:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1484:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
1485:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1486:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1487:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1488:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE void XMC_CAN_MO_SetEventNodePointer(const XMC_CAN_MO_t *const can_mo,
1489:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		                                            const XMC_CAN_MO_POINTER_EVENT_t can_mo_ptr_int,
1490:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		                                            const uint32_t service_request)
1491:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
1492:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   can_mo->can_mo_ptr->MOIPR = ((can_mo->can_mo_ptr->MOIPR ) & ~(uint32_t)((uint32_t)CAN_MO_MOIPR_Ms
1493:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 		                      (service_request << (uint32_t)can_mo_ptr_int);
1494:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
1495:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1496:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** /**
1497:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @param can_mo Pointer to Message Object structure. Refer @ref XMC_CAN_MO_t data structure for de
1498:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1499:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * @return uint32_t	Current Message Object status.
1500:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1501:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Description:</b><br>
1502:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  Returns Message Object status, that indicates message object transfer status and message object
1503:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  information such as the number of the current message object predecessor and successor message 
1504:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *  the list number to which the message object is assigned.
1505:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1506:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * \par<b>Related API's:</b><br>
1507:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  * None
1508:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  *
1509:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****  */
1510:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** 
1511:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** __STATIC_INLINE uint32_t XMC_CAN_MO_GetStatus(const XMC_CAN_MO_t *const can_mo)
1512:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** {
 401              	 .loc 2 1512 0
 402              	 .cfi_startproc
 403              	 
 404              	 
 405              	 
 406 0000 80B4     	 push {r7}
 407              	.LCFI48:
 408              	 .cfi_def_cfa_offset 4
 409              	 .cfi_offset 7,-4
 410 0002 83B0     	 sub sp,sp,#12
 411              	.LCFI49:
 412              	 .cfi_def_cfa_offset 16
 413 0004 00AF     	 add r7,sp,#0
 414              	.LCFI50:
 415              	 .cfi_def_cfa_register 7
 416 0006 7860     	 str r0,[r7,#4]
1513:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h ****   return ((can_mo->can_mo_ptr->MOSTAT));
 417              	 .loc 2 1513 0
 418 0008 7B68     	 ldr r3,[r7,#4]
 419 000a 1B68     	 ldr r3,[r3]
 420 000c DB69     	 ldr r3,[r3,#28]
1514:D:\dholler\Dokumente\uni\bus\xmc\usbCanNode\Libraries\XMCLib\inc\xmc_can.h **** }
 421              	 .loc 2 1514 0
 422 000e 1846     	 mov r0,r3
 423 0010 0C37     	 adds r7,r7,#12
 424              	.LCFI51:
 425              	 .cfi_def_cfa_offset 4
 426 0012 BD46     	 mov sp,r7
 427              	.LCFI52:
 428              	 .cfi_def_cfa_register 13
 429              	 
 430 0014 5DF8047B 	 ldr r7,[sp],#4
 431              	.LCFI53:
 432              	 .cfi_restore 7
 433              	 .cfi_def_cfa_offset 0
 434 0018 7047     	 bx lr
 435              	 .cfi_endproc
 436              	.LFE209:
 438 001a 00BF     	 .section .text._error,"ax",%progbits
 439              	 .align 2
 440              	 .global _error
 441              	 .thumb
 442              	 .thumb_func
 444              	_error:
 445              	.LFB245:
 446              	 .file 3 "../main.c"
   1:../main.c     **** /*
   2:../main.c     ****  * main.c
   3:../main.c     ****  *
   4:../main.c     ****  *  Created on: 2016 Mar 15 18:42:25
   5:../main.c     ****  *  Author: DominikH
   6:../main.c     ****  */
   7:../main.c     **** 
   8:../main.c     **** //#define XMC_DEBUG_ENABLE
   9:../main.c     **** #include <DAVE.h>                 //Declarations from DAVE Code Generation (includes SFR declaratio
  10:../main.c     **** #include <stdlib.h>
  11:../main.c     **** #include <string.h>
  12:../main.c     **** #include <stdarg.h>
  13:../main.c     **** #include <stdbool.h>
  14:../main.c     **** 
  15:../main.c     **** /* Semihosting -specs=rdimon.specs 	*/
  16:../main.c     **** extern void initialise_monitor_handles(void);
  17:../main.c     **** 
  18:../main.c     **** #define MIN(a,b) (((a)<(b))?(a):(b))
  19:../main.c     **** #define MAX(a,b) (((a)>(b))?(a):(b))
  20:../main.c     **** 
  21:../main.c     **** /**
  22:../main.c     **** 
  23:../main.c     ****  * @brief main() - Application entry point
  24:../main.c     ****  *
  25:../main.c     ****  * <b>Details of function</b><br>
  26:../main.c     ****  * This routine is the application entry point. It is invoked by the device startup code. It is res
  27:../main.c     ****  * invoking the APP initialization dispatcher routine - DAVE_Init() and hosting the place-holder fo
  28:../main.c     ****  * code.
  29:../main.c     ****  */
  30:../main.c     **** 
  31:../main.c     **** #define LED1 P5_9
  32:../main.c     **** #define LED2 P5_8
  33:../main.c     **** #define BUTTON1 P15_13
  34:../main.c     **** 
  35:../main.c     **** #define LED_INFO LED1
  36:../main.c     **** #define LED_ERROR LED2
  37:../main.c     **** 
  38:../main.c     **** #ifdef XMC_DEBUG_ENABLE
  39:../main.c     **** #include <stdio.h>
  40:../main.c     **** #define XMC_DEBUG(...) { printf(__VA_ARGS__); }
  41:../main.c     **** #else
  42:../main.c     **** #define XMC_DEBUG(...) { ; }
  43:../main.c     **** #endif
  44:../main.c     **** 
  45:../main.c     **** #define info(...) { \
  46:../main.c     **** 		XMC_DEBUG("Info: %s: %d: %s: ", __FILE__, __LINE__, __FUNCTION__);\
  47:../main.c     **** 		XMC_DEBUG(__VA_ARGS__);\
  48:../main.c     **** 		XMC_DEBUG("\n")\
  49:../main.c     **** 	}
  50:../main.c     **** 
  51:../main.c     **** #define error(...) { \
  52:../main.c     **** 		XMC_DEBUG("Error: %s: %d: %s: ", __FILE__, __LINE__, __FUNCTION__);\
  53:../main.c     **** 		XMC_DEBUG(__VA_ARGS__);\
  54:../main.c     **** 		XMC_DEBUG("\n")\
  55:../main.c     **** 		_error();\
  56:../main.c     **** 	}
  57:../main.c     **** 
  58:../main.c     **** void _error()
  59:../main.c     **** {
 447              	 .loc 3 59 0
 448              	 .cfi_startproc
 449              	 
 450              	 
 451 0000 80B5     	 push {r7,lr}
 452              	.LCFI54:
 453              	 .cfi_def_cfa_offset 8
 454              	 .cfi_offset 7,-8
 455              	 .cfi_offset 14,-4
 456 0002 00AF     	 add r7,sp,#0
 457              	.LCFI55:
 458              	 .cfi_def_cfa_register 7
  60:../main.c     **** 	XMC_GPIO_SetOutputHigh(LED_ERROR);
 459              	 .loc 3 60 0
 460 0004 0248     	 ldr r0,.L14
 461 0006 0821     	 movs r1,#8
 462 0008 FFF7FEFF 	 bl XMC_GPIO_SetOutputHigh
 463              	.L13:
  61:../main.c     **** 	while (1 == 1)
  62:../main.c     **** 		;
 464              	 .loc 3 62 0 discriminator 1
 465 000c FEE7     	 b .L13
 466              	.L15:
 467 000e 00BF     	 .align 2
 468              	.L14:
 469 0010 00850248 	 .word 1208124672
 470              	 .cfi_endproc
 471              	.LFE245:
 473              	 .global usb_rx_buffer
 474              	 .section .bss.usb_rx_buffer,"aw",%nobits
 475              	 .align 2
 478              	usb_rx_buffer:
 479 0000 00000000 	 .space 256
 479      00000000 
 479      00000000 
 479      00000000 
 479      00000000 
 480              	 .global messageObjects
 481              	 .section .data.messageObjects,"aw",%progbits
 482              	 .align 2
 485              	messageObjects:
 486 0000 00000000 	 .word 0
 487 0004 00000000 	 .word CAN_NODE_0_LMO_01_Config
 488 0008 00000000 	 .word CAN_NODE_0_LMO_02_Config
 489 000c 00000000 	 .word CAN_NODE_0_LMO_03_Config
 490 0010 00000000 	 .word CAN_NODE_0_LMO_04_Config
 491 0014 00000000 	 .word CAN_NODE_0_LMO_05_Config
 492 0018 00000000 	 .word CAN_NODE_0_LMO_06_Config
 493 001c 00000000 	 .word CAN_NODE_0_LMO_07_Config
 494 0020 00000000 	 .word CAN_NODE_0_LMO_08_Config
 495 0024 00000000 	 .word CAN_NODE_0_LMO_09_Config
 496 0028 00000000 	 .word CAN_NODE_0_LMO_10_Config
 497 002c 00000000 	 .word CAN_NODE_0_LMO_11_Config
 498 0030 00000000 	 .word CAN_NODE_0_LMO_12_Config
 499 0034 00000000 	 .word CAN_NODE_0_LMO_13_Config
 500 0038 00000000 	 .word CAN_NODE_0_LMO_14_Config
 501 003c 00000000 	 .word CAN_NODE_0_LMO_15_Config
 502 0040 00000000 	 .word CAN_NODE_0_LMO_16_Config
 503 0044 00000000 	 .word CAN_NODE_0_LMO_17_Config
 504 0048 00000000 	 .word CAN_NODE_0_LMO_19_Config
 505 004c 00000000 	 .word CAN_NODE_0_LMO_20_Config
 506 0050 00000000 	 .word CAN_NODE_0_LMO_21_Config
 507 0054 00000000 	 .word CAN_NODE_0_LMO_22_Config
 508 0058 00000000 	 .word CAN_NODE_0_LMO_23_Config
 509 005c 00000000 	 .word CAN_NODE_0_LMO_24_Config
 510 0060 00000000 	 .word CAN_NODE_0_LMO_25_Config
 511 0064 00000000 	 .word CAN_NODE_0_LMO_26_Config
 512 0068 00000000 	 .word CAN_NODE_0_LMO_27_Config
 513 006c 00000000 	 .word CAN_NODE_0_LMO_28_Config
 514 0070 00000000 	 .word CAN_NODE_0_LMO_29_Config
 515 0074 00000000 	 .word CAN_NODE_0_LMO_30_Config
 516 0078 00000000 	 .word CAN_NODE_0_LMO_31_Config
 517 007c 00000000 	 .word CAN_NODE_0_LMO_32_Config
 518              	 .global ReceivedMsg
 519              	 .section .bss.ReceivedMsg,"aw",%nobits
 520              	 .align 2
 523              	ReceivedMsg:
 524 0000 00000000 	 .space 4
 525              	 .global CommandSeperator
 526              	 .section .rodata.CommandSeperator,"a",%progbits
 527              	 .align 2
 530              	CommandSeperator:
 531 0000 2000     	 .ascii " \000"
 532              	 .global echoEnabled
 533 0002 0000     	 .section .bss.echoEnabled,"aw",%nobits
 536              	echoEnabled:
 537 0000 00       	 .space 1
 538              	 .global SendCommand
 539              	 .section .data.SendCommand,"aw",%progbits
 540              	 .align 2
 543              	SendCommand:
 544 0000 00       	 .byte 0
 545 0001 00       	 .byte 0
 546 0002 0000     	 .space 2
 547 0004 00000000 	 .word 0
 548 0008 38       	 .byte 56
 549 0009 01       	 .byte 1
 550 000a 0000     	 .space 2
 551 000c 00040000 	 .word 1024
 552 0010 FFFFFFFF 	 .word -1
 553 0014 08       	 .byte 8
 554 0015 00000000 	 .space 11
 554      00000000 
 554      000000
 555              	 .section .text.is_printable,"ax",%progbits
 556              	 .align 2
 557              	 .global is_printable
 558              	 .thumb
 559              	 .thumb_func
 561              	is_printable:
 562              	.LFB246:
  63:../main.c     **** }
  64:../main.c     **** 
  65:../main.c     **** #define assert(x) { if (!(x)) error(#x); }
  66:../main.c     **** 
  67:../main.c     **** #define USBD_VCOM_BUFFSIZE (256)
  68:../main.c     **** 
  69:../main.c     **** int8_t usb_rx_buffer[USBD_VCOM_BUFFSIZE] =
  70:../main.c     **** { 0 };
  71:../main.c     **** 
  72:../main.c     **** #define messageObjectsMax (32)
  73:../main.c     **** 
  74:../main.c     **** const CAN_NODE_LMO_t * messageObjects[32] =
  75:../main.c     **** { NULL, &CAN_NODE_0_LMO_01_Config, &CAN_NODE_0_LMO_02_Config,
  76:../main.c     **** 		&CAN_NODE_0_LMO_03_Config, &CAN_NODE_0_LMO_04_Config,
  77:../main.c     **** 		&CAN_NODE_0_LMO_05_Config, &CAN_NODE_0_LMO_06_Config,
  78:../main.c     **** 		&CAN_NODE_0_LMO_07_Config, &CAN_NODE_0_LMO_08_Config,
  79:../main.c     **** 		&CAN_NODE_0_LMO_09_Config, &CAN_NODE_0_LMO_10_Config,
  80:../main.c     **** 		&CAN_NODE_0_LMO_11_Config, &CAN_NODE_0_LMO_12_Config,
  81:../main.c     **** 		&CAN_NODE_0_LMO_13_Config, &CAN_NODE_0_LMO_14_Config,
  82:../main.c     **** 		&CAN_NODE_0_LMO_15_Config, &CAN_NODE_0_LMO_16_Config,
  83:../main.c     **** 		&CAN_NODE_0_LMO_17_Config, /* &CAN_NODE_0_LMO_18_Config,*/
  84:../main.c     **** 		&CAN_NODE_0_LMO_19_Config, &CAN_NODE_0_LMO_20_Config,
  85:../main.c     **** 		&CAN_NODE_0_LMO_21_Config, &CAN_NODE_0_LMO_22_Config,
  86:../main.c     **** 		&CAN_NODE_0_LMO_23_Config, &CAN_NODE_0_LMO_24_Config,
  87:../main.c     **** 		&CAN_NODE_0_LMO_25_Config, &CAN_NODE_0_LMO_26_Config,
  88:../main.c     **** 		&CAN_NODE_0_LMO_27_Config, &CAN_NODE_0_LMO_28_Config,
  89:../main.c     **** 		&CAN_NODE_0_LMO_29_Config, &CAN_NODE_0_LMO_30_Config,
  90:../main.c     **** 		&CAN_NODE_0_LMO_31_Config, &CAN_NODE_0_LMO_32_Config };
  91:../main.c     **** 
  92:../main.c     **** XMC_CAN_MO_t *ReceivedMsg = NULL;
  93:../main.c     **** 
  94:../main.c     **** #define S(s) ((int8_t*)(s))
  95:../main.c     **** 
  96:../main.c     **** const char CommandSeperator[] = " ";
  97:../main.c     **** 
  98:../main.c     **** typedef enum echoEnabled
  99:../main.c     **** {
 100:../main.c     **** 	Echo_Off, Echo_On
 101:../main.c     **** } echoEnabled_t;
 102:../main.c     **** 
 103:../main.c     **** echoEnabled_t echoEnabled = Echo_Off;
 104:../main.c     **** 
 105:../main.c     **** typedef enum USB_CAN_STATUS
 106:../main.c     **** {
 107:../main.c     **** 	USB_CAN_STATUS_SUCCESS = 0U, USB_CAN_STATUS_FAILURE
 108:../main.c     **** } USB_CAN_STATUS_t;
 109:../main.c     **** 
 110:../main.c     **** typedef union can_data
 111:../main.c     **** {
 112:../main.c     **** 	uint8_t b[8];
 113:../main.c     **** 	uint32_t i[2];
 114:../main.c     **** } can_data_t;
 115:../main.c     **** 
 116:../main.c     **** typedef enum condition
 117:../main.c     **** {
 118:../main.c     **** 	Condition_Passive, Condition_Active
 119:../main.c     **** } condition_t;
 120:../main.c     **** 
 121:../main.c     **** typedef struct trigger
 122:../main.c     **** {
 123:../main.c     **** 	uint32_t can_identifier;
 124:../main.c     **** 	/* bit numbering in can frame
 125:../main.c     **** 	 *  7  6  5  4  3  2  1  0
 126:../main.c     **** 	 * 15 14 13 12 11 10  9  8
 127:../main.c     **** 	 * 23 22 21 20 19 18 17 16
 128:../main.c     **** 	 * 31 30 29 28 27 26 25 24
 129:../main.c     **** 	 * 39 38 37 36 35 34 33 32
 130:../main.c     **** 	 * 47 46 45 44 43 42 41 40
 131:../main.c     **** 	 * 55 54 53 52 51 50 49 48
 132:../main.c     **** 	 * 63 62 61 60 59 58 57 56
 133:../main.c     **** 	 */
 134:../main.c     **** 	uint8_t can_bit;
 135:../main.c     **** 	bool is_valid;
 136:../main.c     **** } trigger_t;
 137:../main.c     **** 
 138:../main.c     **** typedef enum
 139:../main.c     **** {
 140:../main.c     **** 	SendCommand_Kind_CanMsg, SendCommand_Kind_Surge
 141:../main.c     **** } SendCommand_Kind_t;
 142:../main.c     **** 
 143:../main.c     **** typedef struct SendCommand
 144:../main.c     **** {
 145:../main.c     **** 	condition_t condition;
 146:../main.c     **** 	SendCommand_Kind_t kind;
 147:../main.c     **** 	trigger_t trigger;
 148:../main.c     **** 	uint32_t can_identifier;
 149:../main.c     **** 	int32_t count;
 150:../main.c     **** 	uint8_t can_data_length;
 151:../main.c     **** 	can_data_t can_data;
 152:../main.c     **** 
 153:../main.c     **** } SendCommand_t;
 154:../main.c     **** 
 155:../main.c     **** SendCommand_t SendCommand =
 156:../main.c     **** { .condition = Condition_Passive, .kind = SendCommand_Kind_CanMsg, .trigger =
 157:../main.c     **** { .can_identifier = 0x0, .can_bit = 56, .is_valid = true }, .can_identifier =
 158:../main.c     **** 		0x400, .can_data_length = 8, .count = -1 };
 159:../main.c     **** 
 160:../main.c     **** int is_printable(int8_t data_byte)
 161:../main.c     **** {
 563              	 .loc 3 161 0
 564              	 .cfi_startproc
 565              	 
 566              	 
 567              	 
 568 0000 80B4     	 push {r7}
 569              	.LCFI56:
 570              	 .cfi_def_cfa_offset 4
 571              	 .cfi_offset 7,-4
 572 0002 83B0     	 sub sp,sp,#12
 573              	.LCFI57:
 574              	 .cfi_def_cfa_offset 16
 575 0004 00AF     	 add r7,sp,#0
 576              	.LCFI58:
 577              	 .cfi_def_cfa_register 7
 578 0006 0346     	 mov r3,r0
 579 0008 FB71     	 strb r3,[r7,#7]
 162:../main.c     **** 	return (31 < data_byte) && (data_byte < 126);
 580              	 .loc 3 162 0
 581 000a 97F90730 	 ldrsb r3,[r7,#7]
 582 000e 1F2B     	 cmp r3,#31
 583 0010 05DD     	 ble .L17
 584              	 .loc 3 162 0 is_stmt 0 discriminator 1
 585 0012 97F90730 	 ldrsb r3,[r7,#7]
 586 0016 7D2B     	 cmp r3,#125
 587 0018 01DC     	 bgt .L17
 588              	 .loc 3 162 0 discriminator 3
 589 001a 0123     	 movs r3,#1
 590 001c 00E0     	 b .L18
 591              	.L17:
 592              	 .loc 3 162 0 discriminator 4
 593 001e 0023     	 movs r3,#0
 594              	.L18:
 163:../main.c     **** }
 595              	 .loc 3 163 0 is_stmt 1 discriminator 6
 596 0020 1846     	 mov r0,r3
 597 0022 0C37     	 adds r7,r7,#12
 598              	.LCFI59:
 599              	 .cfi_def_cfa_offset 4
 600 0024 BD46     	 mov sp,r7
 601              	.LCFI60:
 602              	 .cfi_def_cfa_register 13
 603              	 
 604 0026 5DF8047B 	 ldr r7,[sp],#4
 605              	.LCFI61:
 606              	 .cfi_restore 7
 607              	 .cfi_def_cfa_offset 0
 608 002a 7047     	 bx lr
 609              	 .cfi_endproc
 610              	.LFE246:
 612              	 .section .text.USB_CAN_printf,"ax",%progbits
 613              	 .align 2
 614              	 .global USB_CAN_printf
 615              	 .thumb
 616              	 .thumb_func
 618              	USB_CAN_printf:
 619              	.LFB247:
 164:../main.c     **** 
 165:../main.c     **** USB_CAN_STATUS_t USB_CAN_printf(const char *format, ...)
 166:../main.c     **** {
 620              	 .loc 3 166 0
 621              	 .cfi_startproc
 622              	 
 623              	 
 624 0000 0FB4     	 push {r0,r1,r2,r3}
 625              	.LCFI62:
 626              	 .cfi_def_cfa_offset 16
 627              	 .cfi_offset 0,-16
 628              	 .cfi_offset 1,-12
 629              	 .cfi_offset 2,-8
 630              	 .cfi_offset 3,-4
 631 0002 80B5     	 push {r7,lr}
 632              	.LCFI63:
 633              	 .cfi_def_cfa_offset 24
 634              	 .cfi_offset 7,-24
 635              	 .cfi_offset 14,-20
 636 0004 C2B0     	 sub sp,sp,#264
 637              	.LCFI64:
 638              	 .cfi_def_cfa_offset 288
 639 0006 00AF     	 add r7,sp,#0
 640              	.LCFI65:
 641              	 .cfi_def_cfa_register 7
 167:../main.c     **** 	char outPutString[USBD_VCOM_BUFFSIZE];
 168:../main.c     **** 	USB_CAN_STATUS_t result;
 169:../main.c     **** 	va_list args;
 170:../main.c     **** 	va_start(args, format);
 642              	 .loc 3 170 0
 643 0008 07F58A72 	 add r2,r7,#276
 644 000c 3B46     	 mov r3,r7
 645 000e 1A60     	 str r2,[r3]
 171:../main.c     **** 
 172:../main.c     **** 	vsnprintf(outPutString, USBD_VCOM_BUFFSIZE, format, args);
 646              	 .loc 3 172 0
 647 0010 3A1D     	 adds r2,r7,#4
 648 0012 3B46     	 mov r3,r7
 649 0014 1046     	 mov r0,r2
 650 0016 4FF48071 	 mov r1,#256
 651 001a D7F81021 	 ldr r2,[r7,#272]
 652 001e 1B68     	 ldr r3,[r3]
 653 0020 FFF7FEFF 	 bl vsnprintf
 173:../main.c     **** 	result = USBD_VCOM_SendString(S(outPutString));
 654              	 .loc 3 173 0
 655 0024 3B1D     	 adds r3,r7,#4
 656 0026 1846     	 mov r0,r3
 657 0028 FFF7FEFF 	 bl USBD_VCOM_SendString
 658 002c 0346     	 mov r3,r0
 659 002e 87F80731 	 strb r3,[r7,#263]
 174:../main.c     **** 
 175:../main.c     **** 	va_end(args);
 176:../main.c     **** 	return result;
 660              	 .loc 3 176 0
 661 0032 97F80731 	 ldrb r3,[r7,#263]
 177:../main.c     **** }
 662              	 .loc 3 177 0
 663 0036 1846     	 mov r0,r3
 664 0038 07F58477 	 add r7,r7,#264
 665              	.LCFI66:
 666              	 .cfi_def_cfa_offset 24
 667 003c BD46     	 mov sp,r7
 668              	.LCFI67:
 669              	 .cfi_def_cfa_register 13
 670              	 
 671 003e BDE88040 	 pop {r7,lr}
 672              	.LCFI68:
 673              	 .cfi_restore 14
 674              	 .cfi_restore 7
 675              	 .cfi_def_cfa_offset 16
 676 0042 04B0     	 add sp,sp,#16
 677              	.LCFI69:
 678              	 .cfi_restore 3
 679              	 .cfi_restore 2
 680              	 .cfi_restore 1
 681              	 .cfi_restore 0
 682              	 .cfi_def_cfa_offset 0
 683 0044 7047     	 bx lr
 684              	 .cfi_endproc
 685              	.LFE247:
 687 0046 00BF     	 .section .rodata
 688              	 .align 2
 689              	.LC0:
 690 0000 0D0A5265 	 .ascii "\015\012Received 0x%0x %u\000"
 690      63656976 
 690      65642030 
 690      78253078 
 690      20257500 
 691              	 .align 2
 692              	.LC1:
 693 0014 20307825 	 .ascii " 0x%0x\000"
 693      307800
 694 001b 00       	 .align 2
 695              	.LC2:
 696 001c 0D0A00   	 .ascii "\015\012\000"
 697              	 .section .text.printCanMsg,"ax",%progbits
 698              	 .align 2
 699              	 .global printCanMsg
 700              	 .thumb
 701              	 .thumb_func
 703              	printCanMsg:
 704              	.LFB248:
 178:../main.c     **** 
 179:../main.c     **** USB_CAN_STATUS_t printCanMsg(XMC_CAN_MO_t* canMessageObject)
 180:../main.c     **** {
 705              	 .loc 3 180 0
 706              	 .cfi_startproc
 707              	 
 708              	 
 709 0000 80B5     	 push {r7,lr}
 710              	.LCFI70:
 711              	 .cfi_def_cfa_offset 8
 712              	 .cfi_offset 7,-8
 713              	 .cfi_offset 14,-4
 714 0002 84B0     	 sub sp,sp,#16
 715              	.LCFI71:
 716              	 .cfi_def_cfa_offset 24
 717 0004 00AF     	 add r7,sp,#0
 718              	.LCFI72:
 719              	 .cfi_def_cfa_register 7
 720 0006 7860     	 str r0,[r7,#4]
 181:../main.c     **** 	uint8_t length;
 182:../main.c     **** 
 183:../main.c     **** 	if (canMessageObject == NULL)
 721              	 .loc 3 183 0
 722 0008 7B68     	 ldr r3,[r7,#4]
 723 000a 002B     	 cmp r3,#0
 724 000c 01D1     	 bne .L23
 184:../main.c     **** 	{
 185:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 725              	 .loc 3 185 0
 726 000e 0123     	 movs r3,#1
 727 0010 23E0     	 b .L24
 728              	.L23:
 186:../main.c     **** 	}
 187:../main.c     **** 
 188:../main.c     **** 	length = canMessageObject->can_data_length;
 729              	 .loc 3 188 0
 730 0012 7B68     	 ldr r3,[r7,#4]
 731 0014 1B7B     	 ldrb r3,[r3,#12]
 732 0016 BB73     	 strb r3,[r7,#14]
 189:../main.c     **** 
 190:../main.c     **** 	USB_CAN_printf("\r\nReceived 0x%0x %u", canMessageObject->can_identifier,
 733              	 .loc 3 190 0
 734 0018 7B68     	 ldr r3,[r7,#4]
 735 001a 5B68     	 ldr r3,[r3,#4]
 736 001c C3F31C03 	 ubfx r3,r3,#0,#29
 737 0020 1A46     	 mov r2,r3
 738 0022 BB7B     	 ldrb r3,[r7,#14]
 739 0024 0F48     	 ldr r0,.L27
 740 0026 1146     	 mov r1,r2
 741 0028 1A46     	 mov r2,r3
 742 002a FFF7FEFF 	 bl USB_CAN_printf
 743              	.LBB2:
 191:../main.c     **** 			length);
 192:../main.c     **** 
 193:../main.c     **** 	for (uint8_t i = 0; i < length; i++)
 744              	 .loc 3 193 0
 745 002e 0023     	 movs r3,#0
 746 0030 FB73     	 strb r3,[r7,#15]
 747 0032 0AE0     	 b .L25
 748              	.L26:
 194:../main.c     **** 	{
 195:../main.c     **** 		USB_CAN_printf(" 0x%0x", canMessageObject->can_data_byte[i]);
 749              	 .loc 3 195 0 discriminator 3
 750 0034 FB7B     	 ldrb r3,[r7,#15]
 751 0036 7A68     	 ldr r2,[r7,#4]
 752 0038 1344     	 add r3,r3,r2
 753 003a 1B7C     	 ldrb r3,[r3,#16]
 754 003c 0A48     	 ldr r0,.L27+4
 755 003e 1946     	 mov r1,r3
 756 0040 FFF7FEFF 	 bl USB_CAN_printf
 193:../main.c     **** 	{
 757              	 .loc 3 193 0 discriminator 3
 758 0044 FB7B     	 ldrb r3,[r7,#15]
 759 0046 0133     	 adds r3,r3,#1
 760 0048 FB73     	 strb r3,[r7,#15]
 761              	.L25:
 193:../main.c     **** 	{
 762              	 .loc 3 193 0 is_stmt 0 discriminator 1
 763 004a FA7B     	 ldrb r2,[r7,#15]
 764 004c BB7B     	 ldrb r3,[r7,#14]
 765 004e 9A42     	 cmp r2,r3
 766 0050 F0D3     	 bcc .L26
 767              	.LBE2:
 196:../main.c     **** 	}
 197:../main.c     **** 
 198:../main.c     **** 	USB_CAN_printf("\r\n");
 768              	 .loc 3 198 0 is_stmt 1
 769 0052 0648     	 ldr r0,.L27+8
 770 0054 FFF7FEFF 	 bl USB_CAN_printf
 199:../main.c     **** 
 200:../main.c     **** 	return USB_CAN_STATUS_SUCCESS;
 771              	 .loc 3 200 0
 772 0058 0023     	 movs r3,#0
 773              	.L24:
 201:../main.c     **** }
 774              	 .loc 3 201 0
 775 005a 1846     	 mov r0,r3
 776 005c 1037     	 adds r7,r7,#16
 777              	.LCFI73:
 778              	 .cfi_def_cfa_offset 8
 779 005e BD46     	 mov sp,r7
 780              	.LCFI74:
 781              	 .cfi_def_cfa_register 13
 782              	 
 783 0060 80BD     	 pop {r7,pc}
 784              	.L28:
 785 0062 00BF     	 .align 2
 786              	.L27:
 787 0064 00000000 	 .word .LC0
 788 0068 14000000 	 .word .LC1
 789 006c 1C000000 	 .word .LC2
 790              	 .cfi_endproc
 791              	.LFE248:
 793              	 .section .text.consumeCanMsg,"ax",%progbits
 794              	 .align 2
 795              	 .global consumeCanMsg
 796              	 .thumb
 797              	 .thumb_func
 799              	consumeCanMsg:
 800              	.LFB249:
 202:../main.c     **** 
 203:../main.c     **** USB_CAN_STATUS_t consumeCanMsg(XMC_CAN_MO_t* canMessageObject)
 204:../main.c     **** {
 801              	 .loc 3 204 0
 802              	 .cfi_startproc
 803              	 
 804              	 
 805 0000 80B5     	 push {r7,lr}
 806              	.LCFI75:
 807              	 .cfi_def_cfa_offset 8
 808              	 .cfi_offset 7,-8
 809              	 .cfi_offset 14,-4
 810 0002 82B0     	 sub sp,sp,#8
 811              	.LCFI76:
 812              	 .cfi_def_cfa_offset 16
 813 0004 00AF     	 add r7,sp,#0
 814              	.LCFI77:
 815              	 .cfi_def_cfa_register 7
 816 0006 7860     	 str r0,[r7,#4]
 205:../main.c     **** 	if (canMessageObject == NULL)
 817              	 .loc 3 205 0
 818 0008 7B68     	 ldr r3,[r7,#4]
 819 000a 002B     	 cmp r3,#0
 820 000c 01D1     	 bne .L30
 206:../main.c     **** 	{
 207:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 821              	 .loc 3 207 0
 822 000e 0123     	 movs r3,#1
 823 0010 09E0     	 b .L31
 824              	.L30:
 208:../main.c     **** 	}
 209:../main.c     **** 
 210:../main.c     **** 	if (echoEnabled == Echo_On)
 825              	 .loc 3 210 0
 826 0012 074B     	 ldr r3,.L33
 827 0014 1B78     	 ldrb r3,[r3]
 828 0016 012B     	 cmp r3,#1
 829 0018 04D1     	 bne .L32
 211:../main.c     **** 	{
 212:../main.c     **** 		return printCanMsg(canMessageObject);
 830              	 .loc 3 212 0
 831 001a 7868     	 ldr r0,[r7,#4]
 832 001c FFF7FEFF 	 bl printCanMsg
 833 0020 0346     	 mov r3,r0
 834 0022 00E0     	 b .L31
 835              	.L32:
 213:../main.c     **** 	}
 214:../main.c     **** 	else
 215:../main.c     **** 	{
 216:../main.c     **** 		return USB_CAN_STATUS_SUCCESS;
 836              	 .loc 3 216 0
 837 0024 0023     	 movs r3,#0
 838              	.L31:
 217:../main.c     **** 	}
 218:../main.c     **** }
 839              	 .loc 3 218 0
 840 0026 1846     	 mov r0,r3
 841 0028 0837     	 adds r7,r7,#8
 842              	.LCFI78:
 843              	 .cfi_def_cfa_offset 8
 844 002a BD46     	 mov sp,r7
 845              	.LCFI79:
 846              	 .cfi_def_cfa_register 13
 847              	 
 848 002c 80BD     	 pop {r7,pc}
 849              	.L34:
 850 002e 00BF     	 .align 2
 851              	.L33:
 852 0030 00000000 	 .word echoEnabled
 853              	 .cfi_endproc
 854              	.LFE249:
 856              	 .section .text.executeAnalyserCommand,"ax",%progbits
 857              	 .align 2
 858              	 .global executeAnalyserCommand
 859              	 .thumb
 860              	 .thumb_func
 862              	executeAnalyserCommand:
 863              	.LFB250:
 219:../main.c     **** 
 220:../main.c     **** USB_CAN_STATUS_t executeAnalyserCommand(XMC_CAN_NODE_t *const node_ptr, bool enable)
 221:../main.c     **** {
 864              	 .loc 3 221 0
 865              	 .cfi_startproc
 866              	 
 867              	 
 868 0000 80B5     	 push {r7,lr}
 869              	.LCFI80:
 870              	 .cfi_def_cfa_offset 8
 871              	 .cfi_offset 7,-8
 872              	 .cfi_offset 14,-4
 873 0002 82B0     	 sub sp,sp,#8
 874              	.LCFI81:
 875              	 .cfi_def_cfa_offset 16
 876 0004 00AF     	 add r7,sp,#0
 877              	.LCFI82:
 878              	 .cfi_def_cfa_register 7
 879 0006 7860     	 str r0,[r7,#4]
 880 0008 0B46     	 mov r3,r1
 881 000a FB70     	 strb r3,[r7,#3]
 222:../main.c     **** 	if ( enable == true)
 882              	 .loc 3 222 0
 883 000c FB78     	 ldrb r3,[r7,#3]
 884 000e 002B     	 cmp r3,#0
 885 0010 09D0     	 beq .L36
 223:../main.c     **** 	{
 224:../main.c     **** 		XMC_CAN_NODE_SetInitBit(node_ptr);
 886              	 .loc 3 224 0
 887 0012 7868     	 ldr r0,[r7,#4]
 888 0014 FFF7FEFF 	 bl XMC_CAN_NODE_SetInitBit
 225:../main.c     **** 		XMC_CAN_NODE_SetAnalyzerMode(node_ptr);
 889              	 .loc 3 225 0
 890 0018 7868     	 ldr r0,[r7,#4]
 891 001a FFF7FEFF 	 bl XMC_CAN_NODE_SetAnalyzerMode
 226:../main.c     **** 		XMC_CAN_NODE_ResetInitBit(node_ptr);
 892              	 .loc 3 226 0
 893 001e 7868     	 ldr r0,[r7,#4]
 894 0020 FFF7FEFF 	 bl XMC_CAN_NODE_ResetInitBit
 895 0024 08E0     	 b .L37
 896              	.L36:
 227:../main.c     **** 	}
 228:../main.c     **** 	else
 229:../main.c     **** 	{
 230:../main.c     **** 		XMC_CAN_NODE_SetInitBit(node_ptr);
 897              	 .loc 3 230 0
 898 0026 7868     	 ldr r0,[r7,#4]
 899 0028 FFF7FEFF 	 bl XMC_CAN_NODE_SetInitBit
 231:../main.c     **** 		XMC_CAN_NODE_ReSetAnalyzerMode(node_ptr);
 900              	 .loc 3 231 0
 901 002c 7868     	 ldr r0,[r7,#4]
 902 002e FFF7FEFF 	 bl XMC_CAN_NODE_ReSetAnalyzerMode
 232:../main.c     **** 		XMC_CAN_NODE_ResetInitBit(node_ptr);
 903              	 .loc 3 232 0
 904 0032 7868     	 ldr r0,[r7,#4]
 905 0034 FFF7FEFF 	 bl XMC_CAN_NODE_ResetInitBit
 906              	.L37:
 233:../main.c     **** 	}
 234:../main.c     **** }
 907              	 .loc 3 234 0
 908 0038 1846     	 mov r0,r3
 909 003a 0837     	 adds r7,r7,#8
 910              	.LCFI83:
 911              	 .cfi_def_cfa_offset 8
 912 003c BD46     	 mov sp,r7
 913              	.LCFI84:
 914              	 .cfi_def_cfa_register 13
 915              	 
 916 003e 80BD     	 pop {r7,pc}
 917              	 .cfi_endproc
 918              	.LFE250:
 920              	 .section .text.XMC_CAN_MO_Transmission_Ongoing,"ax",%progbits
 921              	 .align 2
 922              	 .global XMC_CAN_MO_Transmission_Ongoing
 923              	 .thumb
 924              	 .thumb_func
 926              	XMC_CAN_MO_Transmission_Ongoing:
 927              	.LFB251:
 235:../main.c     **** 
 236:../main.c     **** uint32_t XMC_CAN_MO_Transmission_Ongoing(const XMC_CAN_MO_t * const mo_ptr)
 237:../main.c     **** {
 928              	 .loc 3 237 0
 929              	 .cfi_startproc
 930              	 
 931              	 
 932 0000 80B5     	 push {r7,lr}
 933              	.LCFI85:
 934              	 .cfi_def_cfa_offset 8
 935              	 .cfi_offset 7,-8
 936              	 .cfi_offset 14,-4
 937 0002 84B0     	 sub sp,sp,#16
 938              	.LCFI86:
 939              	 .cfi_def_cfa_offset 24
 940 0004 00AF     	 add r7,sp,#0
 941              	.LCFI87:
 942              	 .cfi_def_cfa_register 7
 943 0006 7860     	 str r0,[r7,#4]
 238:../main.c     **** 	uint32_t status = XMC_CAN_MO_GetStatus(mo_ptr);
 944              	 .loc 3 238 0
 945 0008 7868     	 ldr r0,[r7,#4]
 946 000a FFF7FEFF 	 bl XMC_CAN_MO_GetStatus
 947 000e F860     	 str r0,[r7,#12]
 239:../main.c     **** 
 240:../main.c     **** 	return ((status) & CAN_MO_MOSTAT_TXRQ_Msk) >> CAN_MO_MOSTAT_TXRQ_Pos;
 948              	 .loc 3 240 0
 949 0010 FB68     	 ldr r3,[r7,#12]
 950 0012 03F48073 	 and r3,r3,#256
 951 0016 1B0A     	 lsrs r3,r3,#8
 241:../main.c     **** }
 952              	 .loc 3 241 0
 953 0018 1846     	 mov r0,r3
 954 001a 1037     	 adds r7,r7,#16
 955              	.LCFI88:
 956              	 .cfi_def_cfa_offset 8
 957 001c BD46     	 mov sp,r7
 958              	.LCFI89:
 959              	 .cfi_def_cfa_register 13
 960              	 
 961 001e 80BD     	 pop {r7,pc}
 962              	 .cfi_endproc
 963              	.LFE251:
 965              	 .section .text.sendCanMsg,"ax",%progbits
 966              	 .align 2
 967              	 .global sendCanMsg
 968              	 .thumb
 969              	 .thumb_func
 971              	sendCanMsg:
 972              	.LFB252:
 242:../main.c     **** 
 243:../main.c     **** XMC_CAN_STATUS_t sendCanMsg(uint32_t can_identifier, uint8_t can_data_length,
 244:../main.c     **** 		uint32_t can_data[2])
 245:../main.c     **** {
 973              	 .loc 3 245 0
 974              	 .cfi_startproc
 975              	 
 976              	 
 977 0000 80B5     	 push {r7,lr}
 978              	.LCFI90:
 979              	 .cfi_def_cfa_offset 8
 980              	 .cfi_offset 7,-8
 981              	 .cfi_offset 14,-4
 982 0002 86B0     	 sub sp,sp,#24
 983              	.LCFI91:
 984              	 .cfi_def_cfa_offset 32
 985 0004 00AF     	 add r7,sp,#0
 986              	.LCFI92:
 987              	 .cfi_def_cfa_register 7
 988 0006 F860     	 str r0,[r7,#12]
 989 0008 0B46     	 mov r3,r1
 990 000a 7A60     	 str r2,[r7,#4]
 991 000c FB72     	 strb r3,[r7,#11]
 246:../main.c     **** 	XMC_CAN_MO_t* mo_ptr = CAN_NODE_0_LMO_02_Config.mo_ptr;
 992              	 .loc 3 246 0
 993 000e 174B     	 ldr r3,.L43
 994 0010 1B68     	 ldr r3,[r3]
 995 0012 7B61     	 str r3,[r7,#20]
 247:../main.c     **** 	XMC_CAN_STATUS_t result;
 248:../main.c     **** 
 249:../main.c     **** 	/* Do not touch MO during transmission */
 250:../main.c     **** 	if (XMC_CAN_MO_Transmission_Ongoing(mo_ptr) == 1U)
 996              	 .loc 3 250 0
 997 0014 7869     	 ldr r0,[r7,#20]
 998 0016 FFF7FEFF 	 bl XMC_CAN_MO_Transmission_Ongoing
 999 001a 0346     	 mov r3,r0
 1000 001c 012B     	 cmp r3,#1
 1001 001e 01D1     	 bne .L41
 251:../main.c     **** 	{
 252:../main.c     **** 		return XMC_CAN_STATUS_BUSY;
 1002              	 .loc 3 252 0
 1003 0020 0223     	 movs r3,#2
 1004 0022 1FE0     	 b .L42
 1005              	.L41:
 253:../main.c     **** 	}
 254:../main.c     **** 
 255:../main.c     **** 	XMC_CAN_MO_SetIdentifier(mo_ptr, can_identifier);
 1006              	 .loc 3 255 0
 1007 0024 7869     	 ldr r0,[r7,#20]
 1008 0026 F968     	 ldr r1,[r7,#12]
 1009 0028 FFF7FEFF 	 bl XMC_CAN_MO_SetIdentifier
 256:../main.c     **** 
 257:../main.c     **** 	mo_ptr->can_data[0] = can_data[0];
 1010              	 .loc 3 257 0
 1011 002c 7B68     	 ldr r3,[r7,#4]
 1012 002e 1A68     	 ldr r2,[r3]
 1013 0030 7B69     	 ldr r3,[r7,#20]
 1014 0032 1A61     	 str r2,[r3,#16]
 258:../main.c     **** 	mo_ptr->can_data[1] = can_data[1];
 1015              	 .loc 3 258 0
 1016 0034 7B68     	 ldr r3,[r7,#4]
 1017 0036 5A68     	 ldr r2,[r3,#4]
 1018 0038 7B69     	 ldr r3,[r7,#20]
 1019 003a 5A61     	 str r2,[r3,#20]
 259:../main.c     **** 	mo_ptr->can_data_length = can_data_length;
 1020              	 .loc 3 259 0
 1021 003c 7B69     	 ldr r3,[r7,#20]
 1022 003e FA7A     	 ldrb r2,[r7,#11]
 1023 0040 1A73     	 strb r2,[r3,#12]
 260:../main.c     **** 	XMC_CAN_MO_UpdateData(mo_ptr);
 1024              	 .loc 3 260 0
 1025 0042 7869     	 ldr r0,[r7,#20]
 1026 0044 FFF7FEFF 	 bl XMC_CAN_MO_UpdateData
 261:../main.c     **** 
 262:../main.c     **** 	XMC_GPIO_SetOutputHigh(LED_INFO);
 1027              	 .loc 3 262 0
 1028 0048 0948     	 ldr r0,.L43+4
 1029 004a 0921     	 movs r1,#9
 1030 004c FFF7FEFF 	 bl XMC_GPIO_SetOutputHigh
 263:../main.c     **** 	result = XMC_CAN_MO_Transmit(mo_ptr);
 1031              	 .loc 3 263 0
 1032 0050 7869     	 ldr r0,[r7,#20]
 1033 0052 FFF7FEFF 	 bl XMC_CAN_MO_Transmit
 1034 0056 0346     	 mov r3,r0
 1035 0058 FB74     	 strb r3,[r7,#19]
 264:../main.c     **** 	XMC_GPIO_SetOutputLow(LED_INFO);
 1036              	 .loc 3 264 0
 1037 005a 0548     	 ldr r0,.L43+4
 1038 005c 0921     	 movs r1,#9
 1039 005e FFF7FEFF 	 bl XMC_GPIO_SetOutputLow
 265:../main.c     **** 
 266:../main.c     **** 	return result;
 1040              	 .loc 3 266 0
 1041 0062 FB7C     	 ldrb r3,[r7,#19]
 1042              	.L42:
 267:../main.c     **** }
 1043              	 .loc 3 267 0
 1044 0064 1846     	 mov r0,r3
 1045 0066 1837     	 adds r7,r7,#24
 1046              	.LCFI93:
 1047              	 .cfi_def_cfa_offset 8
 1048 0068 BD46     	 mov sp,r7
 1049              	.LCFI94:
 1050              	 .cfi_def_cfa_register 13
 1051              	 
 1052 006a 80BD     	 pop {r7,pc}
 1053              	.L44:
 1054              	 .align 2
 1055              	.L43:
 1056 006c 00000000 	 .word CAN_NODE_0_LMO_02_Config
 1057 0070 00850248 	 .word 1208124672
 1058              	 .cfi_endproc
 1059              	.LFE252:
 1061              	 .section .text.executeSurgeCommand,"ax",%progbits
 1062              	 .align 2
 1063              	 .global executeSurgeCommand
 1064              	 .thumb
 1065              	 .thumb_func
 1067              	executeSurgeCommand:
 1068              	.LFB253:
 268:../main.c     **** 
 269:../main.c     **** USB_CAN_STATUS_t executeSurgeCommand()
 270:../main.c     **** {
 1069              	 .loc 3 270 0
 1070              	 .cfi_startproc
 1071              	 
 1072              	 
 1073 0000 80B5     	 push {r7,lr}
 1074              	.LCFI95:
 1075              	 .cfi_def_cfa_offset 8
 1076              	 .cfi_offset 7,-8
 1077              	 .cfi_offset 14,-4
 1078 0002 82B0     	 sub sp,sp,#8
 1079              	.LCFI96:
 1080              	 .cfi_def_cfa_offset 16
 1081 0004 00AF     	 add r7,sp,#0
 1082              	.LCFI97:
 1083              	 .cfi_def_cfa_register 7
 271:../main.c     **** 	USB_CAN_STATUS_t result = USB_CAN_STATUS_SUCCESS;
 1084              	 .loc 3 271 0
 1085 0006 0023     	 movs r3,#0
 1086 0008 FB71     	 strb r3,[r7,#7]
 272:../main.c     **** 	XMC_GPIO_SetOutputHigh(LED_INFO);
 1087              	 .loc 3 272 0
 1088 000a 1148     	 ldr r0,.L49
 1089 000c 0921     	 movs r1,#9
 1090 000e FFF7FEFF 	 bl XMC_GPIO_SetOutputHigh
 1091              	.LBB3:
 273:../main.c     **** 	for (int messageObject = 3; messageObject < messageObjectsMax;
 1092              	 .loc 3 273 0
 1093 0012 0323     	 movs r3,#3
 1094 0014 3B60     	 str r3,[r7]
 1095 0016 0EE0     	 b .L46
 1096              	.L47:
 274:../main.c     **** 			messageObject++)
 275:../main.c     **** 	{
 276:../main.c     **** 		result |= CAN_NODE_MO_Transmit(messageObjects[messageObject]);
 1097              	 .loc 3 276 0
 1098 0018 0E4A     	 ldr r2,.L49+4
 1099 001a 3B68     	 ldr r3,[r7]
 1100 001c 52F82330 	 ldr r3,[r2,r3,lsl#2]
 1101 0020 1846     	 mov r0,r3
 1102 0022 FFF7FEFF 	 bl CAN_NODE_MO_Transmit
 1103 0026 0346     	 mov r3,r0
 1104 0028 1A46     	 mov r2,r3
 1105 002a FB79     	 ldrb r3,[r7,#7]
 1106 002c 1343     	 orrs r3,r3,r2
 1107 002e FB71     	 strb r3,[r7,#7]
 274:../main.c     **** 			messageObject++)
 1108              	 .loc 3 274 0
 1109 0030 3B68     	 ldr r3,[r7]
 1110 0032 0133     	 adds r3,r3,#1
 1111 0034 3B60     	 str r3,[r7]
 1112              	.L46:
 273:../main.c     **** 	for (int messageObject = 3; messageObject < messageObjectsMax;
 1113              	 .loc 3 273 0 discriminator 1
 1114 0036 3B68     	 ldr r3,[r7]
 1115 0038 1F2B     	 cmp r3,#31
 1116 003a EDDD     	 ble .L47
 1117              	.LBE3:
 277:../main.c     **** 	}
 278:../main.c     **** 	XMC_GPIO_SetOutputLow(LED_INFO);
 1118              	 .loc 3 278 0
 1119 003c 0448     	 ldr r0,.L49
 1120 003e 0921     	 movs r1,#9
 1121 0040 FFF7FEFF 	 bl XMC_GPIO_SetOutputLow
 279:../main.c     **** 	return result;
 1122              	 .loc 3 279 0
 1123 0044 FB79     	 ldrb r3,[r7,#7]
 280:../main.c     **** }
 1124              	 .loc 3 280 0
 1125 0046 1846     	 mov r0,r3
 1126 0048 0837     	 adds r7,r7,#8
 1127              	.LCFI98:
 1128              	 .cfi_def_cfa_offset 8
 1129 004a BD46     	 mov sp,r7
 1130              	.LCFI99:
 1131              	 .cfi_def_cfa_register 13
 1132              	 
 1133 004c 80BD     	 pop {r7,pc}
 1134              	.L50:
 1135 004e 00BF     	 .align 2
 1136              	.L49:
 1137 0050 00850248 	 .word 1208124672
 1138 0054 00000000 	 .word messageObjects
 1139              	 .cfi_endproc
 1140              	.LFE253:
 1142              	 .section .text.executeTriggertSendCommand,"ax",%progbits
 1143              	 .align 2
 1144              	 .global executeTriggertSendCommand
 1145              	 .thumb
 1146              	 .thumb_func
 1148              	executeTriggertSendCommand:
 1149              	.LFB254:
 281:../main.c     **** 
 282:../main.c     **** USB_CAN_STATUS_t executeTriggertSendCommand(SendCommand_t *sendCommand)
 283:../main.c     **** {
 1150              	 .loc 3 283 0
 1151              	 .cfi_startproc
 1152              	 
 1153              	 
 1154 0000 80B5     	 push {r7,lr}
 1155              	.LCFI100:
 1156              	 .cfi_def_cfa_offset 8
 1157              	 .cfi_offset 7,-8
 1158              	 .cfi_offset 14,-4
 1159 0002 84B0     	 sub sp,sp,#16
 1160              	.LCFI101:
 1161              	 .cfi_def_cfa_offset 24
 1162 0004 00AF     	 add r7,sp,#0
 1163              	.LCFI102:
 1164              	 .cfi_def_cfa_register 7
 1165 0006 7860     	 str r0,[r7,#4]
 284:../main.c     **** 	XMC_CAN_STATUS_t result;
 285:../main.c     **** 
 286:../main.c     **** 	if (sendCommand == NULL)
 1166              	 .loc 3 286 0
 1167 0008 7B68     	 ldr r3,[r7,#4]
 1168 000a 002B     	 cmp r3,#0
 1169 000c 01D1     	 bne .L52
 287:../main.c     **** 	{
 288:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 1170              	 .loc 3 288 0
 1171 000e 0123     	 movs r3,#1
 1172 0010 45E0     	 b .L53
 1173              	.L52:
 289:../main.c     **** 	}
 290:../main.c     **** 
 291:../main.c     **** 	if (sendCommand->kind == SendCommand_Kind_CanMsg)
 1174              	 .loc 3 291 0
 1175 0012 7B68     	 ldr r3,[r7,#4]
 1176 0014 5B78     	 ldrb r3,[r3,#1]
 1177 0016 002B     	 cmp r3,#0
 1178 0018 28D1     	 bne .L54
 292:../main.c     **** 	{
 293:../main.c     **** 		result = sendCanMsg(sendCommand->can_identifier,
 1179              	 .loc 3 293 0
 1180 001a 7B68     	 ldr r3,[r7,#4]
 1181 001c D968     	 ldr r1,[r3,#12]
 1182 001e 7B68     	 ldr r3,[r7,#4]
 1183 0020 1A7D     	 ldrb r2,[r3,#20]
 294:../main.c     **** 				sendCommand->can_data_length, sendCommand->can_data.i);
 1184              	 .loc 3 294 0
 1185 0022 7B68     	 ldr r3,[r7,#4]
 1186 0024 1833     	 adds r3,r3,#24
 293:../main.c     **** 				sendCommand->can_data_length, sendCommand->can_data.i);
 1187              	 .loc 3 293 0
 1188 0026 0846     	 mov r0,r1
 1189 0028 1146     	 mov r1,r2
 1190 002a 1A46     	 mov r2,r3
 1191 002c FFF7FEFF 	 bl sendCanMsg
 1192 0030 0346     	 mov r3,r0
 1193 0032 FB73     	 strb r3,[r7,#15]
 295:../main.c     **** 
 296:../main.c     **** 		if ((result == XMC_CAN_STATUS_SUCCESS))
 1194              	 .loc 3 296 0
 1195 0034 FB7B     	 ldrb r3,[r7,#15]
 1196 0036 002B     	 cmp r3,#0
 1197 0038 11D1     	 bne .L55
 297:../main.c     **** 		{
 298:../main.c     **** 			if (sendCommand->count > 0)
 1198              	 .loc 3 298 0
 1199 003a 7B68     	 ldr r3,[r7,#4]
 1200 003c 1B69     	 ldr r3,[r3,#16]
 1201 003e 002B     	 cmp r3,#0
 1202 0040 04DD     	 ble .L56
 299:../main.c     **** 			{
 300:../main.c     **** 				sendCommand->count--;
 1203              	 .loc 3 300 0
 1204 0042 7B68     	 ldr r3,[r7,#4]
 1205 0044 1B69     	 ldr r3,[r3,#16]
 1206 0046 5A1E     	 subs r2,r3,#1
 1207 0048 7B68     	 ldr r3,[r7,#4]
 1208 004a 1A61     	 str r2,[r3,#16]
 1209              	.L56:
 301:../main.c     **** 			}
 302:../main.c     **** 
 303:../main.c     **** 			if (sendCommand->count == 0)
 1210              	 .loc 3 303 0
 1211 004c 7B68     	 ldr r3,[r7,#4]
 1212 004e 1B69     	 ldr r3,[r3,#16]
 1213 0050 002B     	 cmp r3,#0
 1214 0052 02D1     	 bne .L57
 304:../main.c     **** 			{
 305:../main.c     **** 				sendCommand->condition = Condition_Passive;
 1215              	 .loc 3 305 0
 1216 0054 7B68     	 ldr r3,[r7,#4]
 1217 0056 0022     	 movs r2,#0
 1218 0058 1A70     	 strb r2,[r3]
 1219              	.L57:
 306:../main.c     **** 			}
 307:../main.c     **** 
 308:../main.c     **** 			return USB_CAN_STATUS_SUCCESS;
 1220              	 .loc 3 308 0
 1221 005a 0023     	 movs r3,#0
 1222 005c 1FE0     	 b .L53
 1223              	.L55:
 309:../main.c     **** 		}
 310:../main.c     **** 		else if (result == XMC_CAN_STATUS_BUSY)
 1224              	 .loc 3 310 0
 1225 005e FB7B     	 ldrb r3,[r7,#15]
 1226 0060 022B     	 cmp r3,#2
 1227 0062 01D1     	 bne .L58
 311:../main.c     **** 		{
 312:../main.c     **** 			return USB_CAN_STATUS_SUCCESS;
 1228              	 .loc 3 312 0
 1229 0064 0023     	 movs r3,#0
 1230 0066 1AE0     	 b .L53
 1231              	.L58:
 313:../main.c     **** 		}
 314:../main.c     **** 		else
 315:../main.c     **** 		{
 316:../main.c     **** 			return USB_CAN_STATUS_FAILURE;
 1232              	 .loc 3 316 0
 1233 0068 0123     	 movs r3,#1
 1234 006a 18E0     	 b .L53
 1235              	.L54:
 317:../main.c     **** 		}
 318:../main.c     **** 	}
 319:../main.c     **** 	else if (sendCommand->kind == SendCommand_Kind_Surge)
 1236              	 .loc 3 319 0
 1237 006c 7B68     	 ldr r3,[r7,#4]
 1238 006e 5B78     	 ldrb r3,[r3,#1]
 1239 0070 012B     	 cmp r3,#1
 1240 0072 13D1     	 bne .L59
 320:../main.c     **** 	{
 321:../main.c     **** 		if (sendCommand->count > 0)
 1241              	 .loc 3 321 0
 1242 0074 7B68     	 ldr r3,[r7,#4]
 1243 0076 1B69     	 ldr r3,[r3,#16]
 1244 0078 002B     	 cmp r3,#0
 1245 007a 04DD     	 ble .L60
 322:../main.c     **** 		{
 323:../main.c     **** 			sendCommand->count--;
 1246              	 .loc 3 323 0
 1247 007c 7B68     	 ldr r3,[r7,#4]
 1248 007e 1B69     	 ldr r3,[r3,#16]
 1249 0080 5A1E     	 subs r2,r3,#1
 1250 0082 7B68     	 ldr r3,[r7,#4]
 1251 0084 1A61     	 str r2,[r3,#16]
 1252              	.L60:
 324:../main.c     **** 		}
 325:../main.c     **** 
 326:../main.c     **** 		if (sendCommand->count == 0)
 1253              	 .loc 3 326 0
 1254 0086 7B68     	 ldr r3,[r7,#4]
 1255 0088 1B69     	 ldr r3,[r3,#16]
 1256 008a 002B     	 cmp r3,#0
 1257 008c 02D1     	 bne .L61
 327:../main.c     **** 		{
 328:../main.c     **** 			sendCommand->condition = Condition_Passive;
 1258              	 .loc 3 328 0
 1259 008e 7B68     	 ldr r3,[r7,#4]
 1260 0090 0022     	 movs r2,#0
 1261 0092 1A70     	 strb r2,[r3]
 1262              	.L61:
 329:../main.c     **** 		}
 330:../main.c     **** 
 331:../main.c     **** 		return executeSurgeCommand();
 1263              	 .loc 3 331 0
 1264 0094 FFF7FEFF 	 bl executeSurgeCommand
 1265 0098 0346     	 mov r3,r0
 1266 009a 00E0     	 b .L53
 1267              	.L59:
 332:../main.c     **** 	}
 333:../main.c     **** 	else
 334:../main.c     **** 	{
 335:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 1268              	 .loc 3 335 0
 1269 009c 0123     	 movs r3,#1
 1270              	.L53:
 336:../main.c     **** 	}
 337:../main.c     **** }
 1271              	 .loc 3 337 0
 1272 009e 1846     	 mov r0,r3
 1273 00a0 1037     	 adds r7,r7,#16
 1274              	.LCFI103:
 1275              	 .cfi_def_cfa_offset 8
 1276 00a2 BD46     	 mov sp,r7
 1277              	.LCFI104:
 1278              	 .cfi_def_cfa_register 13
 1279              	 
 1280 00a4 80BD     	 pop {r7,pc}
 1281              	 .cfi_endproc
 1282              	.LFE254:
 1284 00a6 00BF     	 .section .text.executeSendCommand,"ax",%progbits
 1285              	 .align 2
 1286              	 .global executeSendCommand
 1287              	 .thumb
 1288              	 .thumb_func
 1290              	executeSendCommand:
 1291              	.LFB255:
 338:../main.c     **** 
 339:../main.c     **** USB_CAN_STATUS_t executeSendCommand(SendCommand_t *sendCommand)
 340:../main.c     **** {
 1292              	 .loc 3 340 0
 1293              	 .cfi_startproc
 1294              	 
 1295              	 
 1296 0000 80B5     	 push {r7,lr}
 1297              	.LCFI105:
 1298              	 .cfi_def_cfa_offset 8
 1299              	 .cfi_offset 7,-8
 1300              	 .cfi_offset 14,-4
 1301 0002 82B0     	 sub sp,sp,#8
 1302              	.LCFI106:
 1303              	 .cfi_def_cfa_offset 16
 1304 0004 00AF     	 add r7,sp,#0
 1305              	.LCFI107:
 1306              	 .cfi_def_cfa_register 7
 1307 0006 7860     	 str r0,[r7,#4]
 341:../main.c     **** 	if (sendCommand == NULL)
 1308              	 .loc 3 341 0
 1309 0008 7B68     	 ldr r3,[r7,#4]
 1310 000a 002B     	 cmp r3,#0
 1311 000c 01D1     	 bne .L63
 342:../main.c     **** 	{
 343:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 1312              	 .loc 3 343 0
 1313 000e 0123     	 movs r3,#1
 1314 0010 09E0     	 b .L64
 1315              	.L63:
 344:../main.c     **** 	}
 345:../main.c     **** 
 346:../main.c     **** 	if (sendCommand->condition == Condition_Active)
 1316              	 .loc 3 346 0
 1317 0012 7B68     	 ldr r3,[r7,#4]
 1318 0014 1B78     	 ldrb r3,[r3]
 1319 0016 012B     	 cmp r3,#1
 1320 0018 04D1     	 bne .L65
 347:../main.c     **** 	{
 348:../main.c     **** 		return executeTriggertSendCommand(sendCommand);
 1321              	 .loc 3 348 0
 1322 001a 7868     	 ldr r0,[r7,#4]
 1323 001c FFF7FEFF 	 bl executeTriggertSendCommand
 1324 0020 0346     	 mov r3,r0
 1325 0022 00E0     	 b .L64
 1326              	.L65:
 349:../main.c     **** 	}
 350:../main.c     **** 
 351:../main.c     **** 	return USB_CAN_STATUS_SUCCESS;
 1327              	 .loc 3 351 0
 1328 0024 0023     	 movs r3,#0
 1329              	.L64:
 352:../main.c     **** }
 1330              	 .loc 3 352 0
 1331 0026 1846     	 mov r0,r3
 1332 0028 0837     	 adds r7,r7,#8
 1333              	.LCFI108:
 1334              	 .cfi_def_cfa_offset 8
 1335 002a BD46     	 mov sp,r7
 1336              	.LCFI109:
 1337              	 .cfi_def_cfa_register 13
 1338              	 
 1339 002c 80BD     	 pop {r7,pc}
 1340              	 .cfi_endproc
 1341              	.LFE255:
 1343 002e 00BF     	 .section .rodata
 1344 001f 00       	 .align 2
 1345              	.LC3:
 1346 0020 61637469 	 .ascii "active\000"
 1346      766500
 1347 0027 00       	 .align 2
 1348              	.LC4:
 1349 0028 70617373 	 .ascii "passive\000"
 1349      69766500 
 1350              	 .align 2
 1351              	.LC5:
 1352 0030 3A00     	 .ascii ":\000"
 1353 0032 0000     	 .align 2
 1354              	.LC6:
 1355 0034 73757267 	 .ascii "surge\000"
 1355      6500
 1356              	 .section .text.processSendCommand,"ax",%progbits
 1357              	 .align 2
 1358              	 .global processSendCommand
 1359              	 .thumb
 1360              	 .thumb_func
 1362              	processSendCommand:
 1363              	.LFB256:
 353:../main.c     **** 
 354:../main.c     **** USB_CAN_STATUS_t processSendCommand(char* commandLine)
 355:../main.c     **** {
 1364              	 .loc 3 355 0
 1365              	 .cfi_startproc
 1366              	 
 1367              	 
 1368 0000 80B5     	 push {r7,lr}
 1369              	.LCFI110:
 1370              	 .cfi_def_cfa_offset 8
 1371              	 .cfi_offset 7,-8
 1372              	 .cfi_offset 14,-4
 1373 0002 8EB0     	 sub sp,sp,#56
 1374              	.LCFI111:
 1375              	 .cfi_def_cfa_offset 64
 1376 0004 00AF     	 add r7,sp,#0
 1377              	.LCFI112:
 1378              	 .cfi_def_cfa_register 7
 1379 0006 7860     	 str r0,[r7,#4]
 356:../main.c     **** 	uint32_t can_identifier = 0x400;
 1380              	 .loc 3 356 0
 1381 0008 4FF48063 	 mov r3,#1024
 1382 000c FB62     	 str r3,[r7,#44]
 357:../main.c     **** 	uint8_t can_data_length = 0;
 1383              	 .loc 3 357 0
 1384 000e 0023     	 movs r3,#0
 1385 0010 87F83730 	 strb r3,[r7,#55]
 358:../main.c     **** 	can_data_t can_data;
 359:../main.c     **** 	trigger_t trigger;
 360:../main.c     **** 	SendCommand_Kind_t kind = SendCommand_Kind_CanMsg;
 1386              	 .loc 3 360 0
 1387 0014 0023     	 movs r3,#0
 1388 0016 87F82B30 	 strb r3,[r7,#43]
 361:../main.c     **** 
 362:../main.c     **** 	char *token;
 363:../main.c     **** 
 364:../main.c     **** 	condition_t condition;
 365:../main.c     **** 	int32_t count;
 366:../main.c     **** 
 367:../main.c     **** 	if (commandLine == NULL)
 1389              	 .loc 3 367 0
 1390 001a 7B68     	 ldr r3,[r7,#4]
 1391 001c 002B     	 cmp r3,#0
 1392 001e 01D1     	 bne .L67
 368:../main.c     **** 	{
 369:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 1393              	 .loc 3 369 0
 1394 0020 0123     	 movs r3,#1
 1395 0022 E7E0     	 b .L86
 1396              	.L67:
 370:../main.c     **** 	}
 371:../main.c     **** 
 372:../main.c     **** 	if ((token = strsep(&commandLine, CommandSeperator)) != NULL)
 1397              	 .loc 3 372 0
 1398 0024 3B1D     	 adds r3,r7,#4
 1399 0026 1846     	 mov r0,r3
 1400 0028 7449     	 ldr r1,.L89
 1401 002a FFF7FEFF 	 bl strsep
 1402 002e 0346     	 mov r3,r0
 1403 0030 FB60     	 str r3,[r7,#12]
 1404 0032 FB68     	 ldr r3,[r7,#12]
 1405 0034 002B     	 cmp r3,#0
 1406 0036 49D0     	 beq .L69
 373:../main.c     **** 	{
 374:../main.c     **** 		trigger.is_valid = false;
 1407              	 .loc 3 374 0
 1408 0038 0023     	 movs r3,#0
 1409 003a 7B75     	 strb r3,[r7,#21]
 375:../main.c     **** 		if (!strcmp(token, "active"))
 1410              	 .loc 3 375 0
 1411 003c FB68     	 ldr r3,[r7,#12]
 1412 003e 1846     	 mov r0,r3
 1413 0040 6F49     	 ldr r1,.L89+4
 1414 0042 FFF7FEFF 	 bl strcmp
 1415 0046 0346     	 mov r3,r0
 1416 0048 002B     	 cmp r3,#0
 1417 004a 03D1     	 bne .L70
 376:../main.c     **** 		{
 377:../main.c     **** 			condition = Condition_Active;
 1418              	 .loc 3 377 0
 1419 004c 0123     	 movs r3,#1
 1420 004e 87F83630 	 strb r3,[r7,#54]
 1421 0052 3DE0     	 b .L77
 1422              	.L70:
 378:../main.c     **** 		}
 379:../main.c     **** 		else if (!strcmp(token, "passive"))
 1423              	 .loc 3 379 0
 1424 0054 FB68     	 ldr r3,[r7,#12]
 1425 0056 1846     	 mov r0,r3
 1426 0058 6A49     	 ldr r1,.L89+8
 1427 005a FFF7FEFF 	 bl strcmp
 1428 005e 0346     	 mov r3,r0
 1429 0060 002B     	 cmp r3,#0
 1430 0062 03D1     	 bne .L72
 380:../main.c     **** 		{
 381:../main.c     **** 			condition = Condition_Passive;
 1431              	 .loc 3 381 0
 1432 0064 0023     	 movs r3,#0
 1433 0066 87F83630 	 strb r3,[r7,#54]
 1434 006a 31E0     	 b .L77
 1435              	.L72:
 1436              	.LBB4:
 382:../main.c     **** 		}
 383:../main.c     **** 		else
 384:../main.c     **** 		{
 385:../main.c     **** 			char* innerToken = NULL;
 1437              	 .loc 3 385 0
 1438 006c 0023     	 movs r3,#0
 1439 006e 7B62     	 str r3,[r7,#36]
 386:../main.c     **** 			if ((innerToken = strsep(&token, ":")) != NULL)
 1440              	 .loc 3 386 0
 1441 0070 07F10C03 	 add r3,r7,#12
 1442 0074 1846     	 mov r0,r3
 1443 0076 6449     	 ldr r1,.L89+12
 1444 0078 FFF7FEFF 	 bl strsep
 1445 007c 7862     	 str r0,[r7,#36]
 1446 007e 7B6A     	 ldr r3,[r7,#36]
 1447 0080 002B     	 cmp r3,#0
 1448 0082 11D0     	 beq .L73
 387:../main.c     **** 			{
 388:../main.c     **** 				trigger.can_identifier = strtoul(innerToken, NULL, 0);
 1449              	 .loc 3 388 0
 1450 0084 786A     	 ldr r0,[r7,#36]
 1451 0086 0021     	 movs r1,#0
 1452 0088 0022     	 movs r2,#0
 1453 008a FFF7FEFF 	 bl strtoul
 1454 008e 0346     	 mov r3,r0
 1455 0090 3B61     	 str r3,[r7,#16]
 389:../main.c     **** 			}
 390:../main.c     **** 			else
 391:../main.c     **** 			{
 392:../main.c     **** 				return USB_CAN_STATUS_FAILURE;
 393:../main.c     **** 			}
 394:../main.c     **** 			if ((innerToken = strsep(&token, ":")) != NULL)
 1456              	 .loc 3 394 0
 1457 0092 07F10C03 	 add r3,r7,#12
 1458 0096 1846     	 mov r0,r3
 1459 0098 5B49     	 ldr r1,.L89+12
 1460 009a FFF7FEFF 	 bl strsep
 1461 009e 7862     	 str r0,[r7,#36]
 1462 00a0 7B6A     	 ldr r3,[r7,#36]
 1463 00a2 002B     	 cmp r3,#0
 1464 00a4 10D0     	 beq .L75
 1465 00a6 01E0     	 b .L87
 1466              	.L73:
 392:../main.c     **** 			}
 1467              	 .loc 3 392 0
 1468 00a8 0123     	 movs r3,#1
 1469 00aa A3E0     	 b .L86
 1470              	.L87:
 395:../main.c     **** 			{
 396:../main.c     **** 				trigger.can_bit = (uint8_t) strtoul(innerToken, NULL, 0);
 1471              	 .loc 3 396 0
 1472 00ac 786A     	 ldr r0,[r7,#36]
 1473 00ae 0021     	 movs r1,#0
 1474 00b0 0022     	 movs r2,#0
 1475 00b2 FFF7FEFF 	 bl strtoul
 1476 00b6 0346     	 mov r3,r0
 1477 00b8 DBB2     	 uxtb r3,r3
 1478 00ba 3B75     	 strb r3,[r7,#20]
 397:../main.c     **** 			}
 398:../main.c     **** 			else
 399:../main.c     **** 			{
 400:../main.c     **** 				return USB_CAN_STATUS_FAILURE;
 401:../main.c     **** 			}
 402:../main.c     **** 			condition = Condition_Passive;
 1479              	 .loc 3 402 0
 1480 00bc 0023     	 movs r3,#0
 1481 00be 87F83630 	 strb r3,[r7,#54]
 403:../main.c     **** 			trigger.is_valid = true;
 1482              	 .loc 3 403 0
 1483 00c2 0123     	 movs r3,#1
 1484 00c4 7B75     	 strb r3,[r7,#21]
 1485 00c6 03E0     	 b .L77
 1486              	.L75:
 400:../main.c     **** 			}
 1487              	 .loc 3 400 0
 1488 00c8 0123     	 movs r3,#1
 1489 00ca 93E0     	 b .L86
 1490              	.L69:
 1491              	.LBE4:
 404:../main.c     **** 
 405:../main.c     **** 		}
 406:../main.c     **** 	}
 407:../main.c     **** 	else
 408:../main.c     **** 	{
 409:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 1492              	 .loc 3 409 0
 1493 00cc 0123     	 movs r3,#1
 1494 00ce 91E0     	 b .L86
 1495              	.L77:
 410:../main.c     **** 	}
 411:../main.c     **** 
 412:../main.c     **** 	if ((token = strsep(&commandLine, CommandSeperator)) != NULL)
 1496              	 .loc 3 412 0
 1497 00d0 3B1D     	 adds r3,r7,#4
 1498 00d2 1846     	 mov r0,r3
 1499 00d4 4949     	 ldr r1,.L89
 1500 00d6 FFF7FEFF 	 bl strsep
 1501 00da 0346     	 mov r3,r0
 1502 00dc FB60     	 str r3,[r7,#12]
 1503 00de FB68     	 ldr r3,[r7,#12]
 1504 00e0 002B     	 cmp r3,#0
 1505 00e2 30D0     	 beq .L78
 413:../main.c     **** 	{
 414:../main.c     **** 		if (!strcmp(token, "surge"))
 1506              	 .loc 3 414 0
 1507 00e4 FB68     	 ldr r3,[r7,#12]
 1508 00e6 1846     	 mov r0,r3
 1509 00e8 4849     	 ldr r1,.L89+16
 1510 00ea FFF7FEFF 	 bl strcmp
 1511 00ee 0346     	 mov r3,r0
 1512 00f0 002B     	 cmp r3,#0
 1513 00f2 16D1     	 bne .L79
 415:../main.c     **** 		{
 416:../main.c     **** 			SendCommand.condition = Condition_Passive;
 1514              	 .loc 3 416 0
 1515 00f4 464B     	 ldr r3,.L89+20
 1516 00f6 0022     	 movs r2,#0
 1517 00f8 1A70     	 strb r2,[r3]
 417:../main.c     **** 			SendCommand.trigger = trigger;
 1518              	 .loc 3 417 0
 1519 00fa 454B     	 ldr r3,.L89+20
 1520 00fc 0433     	 adds r3,r3,#4
 1521 00fe 07F11002 	 add r2,r7,#16
 1522 0102 92E80300 	 ldmia r2,{r0,r1}
 1523 0106 83E80300 	 stmia r3,{r0,r1}
 418:../main.c     **** 			SendCommand.kind = SendCommand_Kind_Surge;
 1524              	 .loc 3 418 0
 1525 010a 414B     	 ldr r3,.L89+20
 1526 010c 0122     	 movs r2,#1
 1527 010e 5A70     	 strb r2,[r3,#1]
 419:../main.c     **** 			SendCommand.count = 1;
 1528              	 .loc 3 419 0
 1529 0110 3F4B     	 ldr r3,.L89+20
 1530 0112 0122     	 movs r2,#1
 1531 0114 1A61     	 str r2,[r3,#16]
 420:../main.c     **** 			SendCommand.condition = condition;
 1532              	 .loc 3 420 0
 1533 0116 3E4A     	 ldr r2,.L89+20
 1534 0118 97F83630 	 ldrb r3,[r7,#54]
 1535 011c 1370     	 strb r3,[r2]
 421:../main.c     **** 			return USB_CAN_STATUS_SUCCESS;
 1536              	 .loc 3 421 0
 1537 011e 0023     	 movs r3,#0
 1538 0120 68E0     	 b .L86
 1539              	.L79:
 422:../main.c     **** 		}
 423:../main.c     **** 		else
 424:../main.c     **** 		{
 425:../main.c     **** 			count = strtol(token, NULL, 0);
 1540              	 .loc 3 425 0
 1541 0122 FB68     	 ldr r3,[r7,#12]
 1542 0124 1846     	 mov r0,r3
 1543 0126 0021     	 movs r1,#0
 1544 0128 0022     	 movs r2,#0
 1545 012a FFF7FEFF 	 bl strtol
 1546 012e 3862     	 str r0,[r7,#32]
 426:../main.c     **** 		}
 427:../main.c     **** 	}
 428:../main.c     **** 	else
 429:../main.c     **** 	{
 430:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 431:../main.c     **** 	}
 432:../main.c     **** 
 433:../main.c     **** 	if ((token = strsep(&commandLine, CommandSeperator)) != NULL)
 1547              	 .loc 3 433 0
 1548 0130 3B1D     	 adds r3,r7,#4
 1549 0132 1846     	 mov r0,r3
 1550 0134 3149     	 ldr r1,.L89
 1551 0136 FFF7FEFF 	 bl strsep
 1552 013a 0346     	 mov r3,r0
 1553 013c FB60     	 str r3,[r7,#12]
 1554 013e FB68     	 ldr r3,[r7,#12]
 1555 0140 002B     	 cmp r3,#0
 1556 0142 0CD0     	 beq .L81
 1557 0144 01E0     	 b .L88
 1558              	.L78:
 430:../main.c     **** 	}
 1559              	 .loc 3 430 0
 1560 0146 0123     	 movs r3,#1
 1561 0148 54E0     	 b .L86
 1562              	.L88:
 434:../main.c     **** 	{
 435:../main.c     **** 		can_identifier = strtoul(token, NULL, 0);
 1563              	 .loc 3 435 0
 1564 014a FB68     	 ldr r3,[r7,#12]
 1565 014c 1846     	 mov r0,r3
 1566 014e 0021     	 movs r1,#0
 1567 0150 0022     	 movs r2,#0
 1568 0152 FFF7FEFF 	 bl strtoul
 1569 0156 F862     	 str r0,[r7,#44]
 1570              	.LBB5:
 436:../main.c     **** 	}
 437:../main.c     **** 	else
 438:../main.c     **** 	{
 439:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 440:../main.c     **** 	}
 441:../main.c     **** 
 442:../main.c     **** 	for (int i = 0; i < 8; i++)
 1571              	 .loc 3 442 0
 1572 0158 0023     	 movs r3,#0
 1573 015a 3B63     	 str r3,[r7,#48]
 1574 015c 21E0     	 b .L83
 1575              	.L81:
 1576              	.LBE5:
 439:../main.c     **** 	}
 1577              	 .loc 3 439 0
 1578 015e 0123     	 movs r3,#1
 1579 0160 48E0     	 b .L86
 1580              	.L85:
 1581              	.LBB6:
 443:../main.c     **** 	{
 444:../main.c     **** 		if ((token = strsep(&commandLine, CommandSeperator)) != NULL)
 1582              	 .loc 3 444 0
 1583 0162 3B1D     	 adds r3,r7,#4
 1584 0164 1846     	 mov r0,r3
 1585 0166 2549     	 ldr r1,.L89
 1586 0168 FFF7FEFF 	 bl strsep
 1587 016c 0346     	 mov r3,r0
 1588 016e FB60     	 str r3,[r7,#12]
 1589 0170 FB68     	 ldr r3,[r7,#12]
 1590 0172 002B     	 cmp r3,#0
 1591 0174 12D0     	 beq .L84
 445:../main.c     **** 		{
 446:../main.c     **** 			can_data.b[i] = strtoul(token, NULL, 0);
 1592              	 .loc 3 446 0
 1593 0176 FB68     	 ldr r3,[r7,#12]
 1594 0178 1846     	 mov r0,r3
 1595 017a 0021     	 movs r1,#0
 1596 017c 0022     	 movs r2,#0
 1597 017e FFF7FEFF 	 bl strtoul
 1598 0182 0346     	 mov r3,r0
 1599 0184 D9B2     	 uxtb r1,r3
 1600 0186 07F11802 	 add r2,r7,#24
 1601 018a 3B6B     	 ldr r3,[r7,#48]
 1602 018c 1344     	 add r3,r3,r2
 1603 018e 0A46     	 mov r2,r1
 1604 0190 1A70     	 strb r2,[r3]
 447:../main.c     **** 			can_data_length++;
 1605              	 .loc 3 447 0
 1606 0192 97F83730 	 ldrb r3,[r7,#55]
 1607 0196 0133     	 adds r3,r3,#1
 1608 0198 87F83730 	 strb r3,[r7,#55]
 1609              	.L84:
 442:../main.c     **** 	{
 1610              	 .loc 3 442 0 discriminator 2
 1611 019c 3B6B     	 ldr r3,[r7,#48]
 1612 019e 0133     	 adds r3,r3,#1
 1613 01a0 3B63     	 str r3,[r7,#48]
 1614              	.L83:
 442:../main.c     **** 	{
 1615              	 .loc 3 442 0 is_stmt 0 discriminator 1
 1616 01a2 3B6B     	 ldr r3,[r7,#48]
 1617 01a4 072B     	 cmp r3,#7
 1618 01a6 DCDD     	 ble .L85
 1619              	.LBE6:
 448:../main.c     **** 		}
 449:../main.c     **** 	}
 450:../main.c     **** 
 451:../main.c     **** 	SendCommand.condition = Condition_Passive;
 1620              	 .loc 3 451 0 is_stmt 1
 1621 01a8 194B     	 ldr r3,.L89+20
 1622 01aa 0022     	 movs r2,#0
 1623 01ac 1A70     	 strb r2,[r3]
 452:../main.c     **** 	SendCommand.trigger = trigger;
 1624              	 .loc 3 452 0
 1625 01ae 184B     	 ldr r3,.L89+20
 1626 01b0 0433     	 adds r3,r3,#4
 1627 01b2 07F11002 	 add r2,r7,#16
 1628 01b6 92E80300 	 ldmia r2,{r0,r1}
 1629 01ba 83E80300 	 stmia r3,{r0,r1}
 453:../main.c     **** 	SendCommand.kind = kind;
 1630              	 .loc 3 453 0
 1631 01be 144A     	 ldr r2,.L89+20
 1632 01c0 97F82B30 	 ldrb r3,[r7,#43]
 1633 01c4 5370     	 strb r3,[r2,#1]
 454:../main.c     **** 	SendCommand.count = count;
 1634              	 .loc 3 454 0
 1635 01c6 124A     	 ldr r2,.L89+20
 1636 01c8 3B6A     	 ldr r3,[r7,#32]
 1637 01ca 1361     	 str r3,[r2,#16]
 455:../main.c     **** 	SendCommand.can_identifier = can_identifier;
 1638              	 .loc 3 455 0
 1639 01cc 104A     	 ldr r2,.L89+20
 1640 01ce FB6A     	 ldr r3,[r7,#44]
 1641 01d0 D360     	 str r3,[r2,#12]
 456:../main.c     **** 	SendCommand.can_data_length = can_data_length;
 1642              	 .loc 3 456 0
 1643 01d2 0F4A     	 ldr r2,.L89+20
 1644 01d4 97F83730 	 ldrb r3,[r7,#55]
 1645 01d8 1375     	 strb r3,[r2,#20]
 457:../main.c     **** 	SendCommand.can_data = can_data;
 1646              	 .loc 3 457 0
 1647 01da 0D4B     	 ldr r3,.L89+20
 1648 01dc 1833     	 adds r3,r3,#24
 1649 01de 07F11802 	 add r2,r7,#24
 1650 01e2 92E80300 	 ldmia r2,{r0,r1}
 1651 01e6 83E80300 	 stmia r3,{r0,r1}
 458:../main.c     **** 	SendCommand.condition = condition;
 1652              	 .loc 3 458 0
 1653 01ea 094A     	 ldr r2,.L89+20
 1654 01ec 97F83630 	 ldrb r3,[r7,#54]
 1655 01f0 1370     	 strb r3,[r2]
 459:../main.c     **** 
 460:../main.c     **** 	return USB_CAN_STATUS_SUCCESS;
 1656              	 .loc 3 460 0
 1657 01f2 0023     	 movs r3,#0
 1658              	.L86:
 461:../main.c     **** }
 1659              	 .loc 3 461 0 discriminator 1
 1660 01f4 1846     	 mov r0,r3
 1661 01f6 3837     	 adds r7,r7,#56
 1662              	.LCFI113:
 1663              	 .cfi_def_cfa_offset 8
 1664 01f8 BD46     	 mov sp,r7
 1665              	.LCFI114:
 1666              	 .cfi_def_cfa_register 13
 1667              	 
 1668 01fa 80BD     	 pop {r7,pc}
 1669              	.L90:
 1670              	 .align 2
 1671              	.L89:
 1672 01fc 00000000 	 .word CommandSeperator
 1673 0200 20000000 	 .word .LC3
 1674 0204 28000000 	 .word .LC4
 1675 0208 30000000 	 .word .LC5
 1676 020c 34000000 	 .word .LC6
 1677 0210 00000000 	 .word SendCommand
 1678              	 .cfi_endproc
 1679              	.LFE256:
 1681              	 .section .text.processSurgeCommand,"ax",%progbits
 1682              	 .align 2
 1683              	 .global processSurgeCommand
 1684              	 .thumb
 1685              	 .thumb_func
 1687              	processSurgeCommand:
 1688              	.LFB257:
 462:../main.c     **** 
 463:../main.c     **** USB_CAN_STATUS_t processSurgeCommand()
 464:../main.c     **** {
 1689              	 .loc 3 464 0
 1690              	 .cfi_startproc
 1691              	 
 1692              	 
 1693 0000 80B5     	 push {r7,lr}
 1694              	.LCFI115:
 1695              	 .cfi_def_cfa_offset 8
 1696              	 .cfi_offset 7,-8
 1697              	 .cfi_offset 14,-4
 1698 0002 00AF     	 add r7,sp,#0
 1699              	.LCFI116:
 1700              	 .cfi_def_cfa_register 7
 465:../main.c     **** 	return executeSurgeCommand();
 1701              	 .loc 3 465 0
 1702 0004 FFF7FEFF 	 bl executeSurgeCommand
 1703 0008 0346     	 mov r3,r0
 466:../main.c     **** }
 1704              	 .loc 3 466 0
 1705 000a 1846     	 mov r0,r3
 1706 000c 80BD     	 pop {r7,pc}
 1707              	 .cfi_endproc
 1708              	.LFE257:
 1710 000e 00BF     	 .section .rodata
 1711 003a 0000     	 .align 2
 1712              	.LC7:
 1713 003c 6F6E00   	 .ascii "on\000"
 1714              	 .section .text.processEchoCommand,"ax",%progbits
 1715              	 .align 2
 1716              	 .global processEchoCommand
 1717              	 .thumb
 1718              	 .thumb_func
 1720              	processEchoCommand:
 1721              	.LFB258:
 467:../main.c     **** 
 468:../main.c     **** USB_CAN_STATUS_t processEchoCommand(char* commandLine)
 469:../main.c     **** {
 1722              	 .loc 3 469 0
 1723              	 .cfi_startproc
 1724              	 
 1725              	 
 1726 0000 80B5     	 push {r7,lr}
 1727              	.LCFI117:
 1728              	 .cfi_def_cfa_offset 8
 1729              	 .cfi_offset 7,-8
 1730              	 .cfi_offset 14,-4
 1731 0002 82B0     	 sub sp,sp,#8
 1732              	.LCFI118:
 1733              	 .cfi_def_cfa_offset 16
 1734 0004 00AF     	 add r7,sp,#0
 1735              	.LCFI119:
 1736              	 .cfi_def_cfa_register 7
 1737 0006 7860     	 str r0,[r7,#4]
 470:../main.c     **** 	if (!strcmp(commandLine, "on"))
 1738              	 .loc 3 470 0
 1739 0008 7868     	 ldr r0,[r7,#4]
 1740 000a 0949     	 ldr r1,.L97
 1741 000c FFF7FEFF 	 bl strcmp
 1742 0010 0346     	 mov r3,r0
 1743 0012 002B     	 cmp r3,#0
 1744 0014 03D1     	 bne .L94
 471:../main.c     **** 	{
 472:../main.c     **** 		echoEnabled = Echo_On;
 1745              	 .loc 3 472 0
 1746 0016 074B     	 ldr r3,.L97+4
 1747 0018 0122     	 movs r2,#1
 1748 001a 1A70     	 strb r2,[r3]
 1749 001c 02E0     	 b .L95
 1750              	.L94:
 473:../main.c     **** 	}
 474:../main.c     **** 	else
 475:../main.c     **** 	{
 476:../main.c     **** 		echoEnabled = Echo_Off;
 1751              	 .loc 3 476 0
 1752 001e 054B     	 ldr r3,.L97+4
 1753 0020 0022     	 movs r2,#0
 1754 0022 1A70     	 strb r2,[r3]
 1755              	.L95:
 477:../main.c     **** 	}
 478:../main.c     **** 
 479:../main.c     **** 	return USB_CAN_STATUS_SUCCESS;
 1756              	 .loc 3 479 0
 1757 0024 0023     	 movs r3,#0
 480:../main.c     **** }
 1758              	 .loc 3 480 0
 1759 0026 1846     	 mov r0,r3
 1760 0028 0837     	 adds r7,r7,#8
 1761              	.LCFI120:
 1762              	 .cfi_def_cfa_offset 8
 1763 002a BD46     	 mov sp,r7
 1764              	.LCFI121:
 1765              	 .cfi_def_cfa_register 13
 1766              	 
 1767 002c 80BD     	 pop {r7,pc}
 1768              	.L98:
 1769 002e 00BF     	 .align 2
 1770              	.L97:
 1771 0030 3C000000 	 .word .LC7
 1772 0034 00000000 	 .word echoEnabled
 1773              	 .cfi_endproc
 1774              	.LFE258:
 1776              	 .section .text.processAnalyzerCommand,"ax",%progbits
 1777              	 .align 2
 1778              	 .global processAnalyzerCommand
 1779              	 .thumb
 1780              	 .thumb_func
 1782              	processAnalyzerCommand:
 1783              	.LFB259:
 481:../main.c     **** 
 482:../main.c     **** 
 483:../main.c     **** USB_CAN_STATUS_t processAnalyzerCommand(char* commandLine)
 484:../main.c     **** {
 1784              	 .loc 3 484 0
 1785              	 .cfi_startproc
 1786              	 
 1787              	 
 1788 0000 80B5     	 push {r7,lr}
 1789              	.LCFI122:
 1790              	 .cfi_def_cfa_offset 8
 1791              	 .cfi_offset 7,-8
 1792              	 .cfi_offset 14,-4
 1793 0002 84B0     	 sub sp,sp,#16
 1794              	.LCFI123:
 1795              	 .cfi_def_cfa_offset 24
 1796 0004 00AF     	 add r7,sp,#0
 1797              	.LCFI124:
 1798              	 .cfi_def_cfa_register 7
 1799 0006 7860     	 str r0,[r7,#4]
 485:../main.c     **** 	XMC_CAN_NODE_t *const node_ptr = CAN_NODE_0.node_ptr;
 1800              	 .loc 3 485 0
 1801 0008 0B4B     	 ldr r3,.L102
 1802 000a 5B68     	 ldr r3,[r3,#4]
 1803 000c BB60     	 str r3,[r7,#8]
 486:../main.c     **** 	bool enable = false;
 1804              	 .loc 3 486 0
 1805 000e 0023     	 movs r3,#0
 1806 0010 FB73     	 strb r3,[r7,#15]
 487:../main.c     **** 
 488:../main.c     **** 	if (!strcmp(commandLine, "on"))
 1807              	 .loc 3 488 0
 1808 0012 7868     	 ldr r0,[r7,#4]
 1809 0014 0949     	 ldr r1,.L102+4
 1810 0016 FFF7FEFF 	 bl strcmp
 1811 001a 0346     	 mov r3,r0
 1812 001c 002B     	 cmp r3,#0
 1813 001e 01D1     	 bne .L100
 489:../main.c     **** 	{
 490:../main.c     **** 		enable = true;
 1814              	 .loc 3 490 0
 1815 0020 0123     	 movs r3,#1
 1816 0022 FB73     	 strb r3,[r7,#15]
 1817              	.L100:
 491:../main.c     **** 	}
 492:../main.c     **** 
 493:../main.c     **** 	return executeAnalyserCommand(node_ptr, enable);
 1818              	 .loc 3 493 0
 1819 0024 FB7B     	 ldrb r3,[r7,#15]
 1820 0026 B868     	 ldr r0,[r7,#8]
 1821 0028 1946     	 mov r1,r3
 1822 002a FFF7FEFF 	 bl executeAnalyserCommand
 1823 002e 0346     	 mov r3,r0
 494:../main.c     **** }
 1824              	 .loc 3 494 0
 1825 0030 1846     	 mov r0,r3
 1826 0032 1037     	 adds r7,r7,#16
 1827              	.LCFI125:
 1828              	 .cfi_def_cfa_offset 8
 1829 0034 BD46     	 mov sp,r7
 1830              	.LCFI126:
 1831              	 .cfi_def_cfa_register 13
 1832              	 
 1833 0036 80BD     	 pop {r7,pc}
 1834              	.L103:
 1835              	 .align 2
 1836              	.L102:
 1837 0038 00000000 	 .word CAN_NODE_0
 1838 003c 3C000000 	 .word .LC7
 1839              	 .cfi_endproc
 1840              	.LFE259:
 1842              	 .section .rodata
 1843 003f 00       	 .align 2
 1844              	.LC8:
 1845 0040 53656E64 	 .ascii "Send\000"
 1845      00
 1846 0045 000000   	 .align 2
 1847              	.LC9:
 1848 0048 4563686F 	 .ascii "Echo\000"
 1848      00
 1849 004d 000000   	 .align 2
 1850              	.LC10:
 1851 0050 53757267 	 .ascii "Surge\000"
 1851      6500
 1852 0056 0000     	 .align 2
 1853              	.LC11:
 1854 0058 416E616C 	 .ascii "Analyzer\000"
 1854      797A6572 
 1854      00
 1855 0061 000000   	 .align 2
 1856              	.LC12:
 1857 0064 0D0A556E 	 .ascii "\015\012Unknown command '%s'\015\012\000"
 1857      6B6E6F77 
 1857      6E20636F 
 1857      6D6D616E 
 1857      64202725 
 1858 007d 000000   	 .align 2
 1859              	.LC13:
 1860 0080 0D0A5265 	 .ascii "\015\012Result: Success\015\012\000"
 1860      73756C74 
 1860      3A205375 
 1860      63636573 
 1860      730D0A00 
 1861              	 .align 2
 1862              	.LC14:
 1863 0094 0D0A5265 	 .ascii "\015\012Result: Failure\015\012\000"
 1863      73756C74 
 1863      3A204661 
 1863      696C7572 
 1863      650D0A00 
 1864              	 .section .text.processCommand,"ax",%progbits
 1865              	 .align 2
 1866              	 .global processCommand
 1867              	 .thumb
 1868              	 .thumb_func
 1870              	processCommand:
 1871              	.LFB260:
 495:../main.c     **** 
 496:../main.c     **** USB_CAN_STATUS_t processCommand(int8_t usb_rx_buffer[])
 497:../main.c     **** {
 1872              	 .loc 3 497 0
 1873              	 .cfi_startproc
 1874              	 
 1875              	 
 1876 0000 80B5     	 push {r7,lr}
 1877              	.LCFI127:
 1878              	 .cfi_def_cfa_offset 8
 1879              	 .cfi_offset 7,-8
 1880              	 .cfi_offset 14,-4
 1881 0002 86B0     	 sub sp,sp,#24
 1882              	.LCFI128:
 1883              	 .cfi_def_cfa_offset 32
 1884 0004 00AF     	 add r7,sp,#0
 1885              	.LCFI129:
 1886              	 .cfi_def_cfa_register 7
 1887 0006 7860     	 str r0,[r7,#4]
 498:../main.c     **** 	USB_CAN_STATUS_t result = USB_CAN_STATUS_FAILURE;
 1888              	 .loc 3 498 0
 1889 0008 0123     	 movs r3,#1
 1890 000a FB75     	 strb r3,[r7,#23]
 499:../main.c     **** 	char* commandLine = (char*) usb_rx_buffer;
 1891              	 .loc 3 499 0
 1892 000c 7B68     	 ldr r3,[r7,#4]
 1893 000e BB60     	 str r3,[r7,#8]
 500:../main.c     **** 	const char* cmd = NULL;
 1894              	 .loc 3 500 0
 1895 0010 0023     	 movs r3,#0
 1896 0012 3B61     	 str r3,[r7,#16]
 501:../main.c     **** 	char *token;
 502:../main.c     **** 
 503:../main.c     **** 	if (usb_rx_buffer == NULL)
 1897              	 .loc 3 503 0
 1898 0014 7B68     	 ldr r3,[r7,#4]
 1899 0016 002B     	 cmp r3,#0
 1900 0018 01D1     	 bne .L105
 504:../main.c     **** 	{
 505:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 1901              	 .loc 3 505 0
 1902 001a 0123     	 movs r3,#1
 1903 001c 50E0     	 b .L114
 1904              	.L105:
 506:../main.c     **** 	}
 507:../main.c     **** 
 508:../main.c     **** 	if ((token = strsep(&commandLine, CommandSeperator)) != NULL)
 1905              	 .loc 3 508 0
 1906 001e 07F10803 	 add r3,r7,#8
 1907 0022 1846     	 mov r0,r3
 1908 0024 2849     	 ldr r1,.L115
 1909 0026 FFF7FEFF 	 bl strsep
 1910 002a F860     	 str r0,[r7,#12]
 1911 002c FB68     	 ldr r3,[r7,#12]
 1912 002e 002B     	 cmp r3,#0
 1913 0030 45D0     	 beq .L107
 509:../main.c     **** 	{
 510:../main.c     **** 		cmd = token;
 1914              	 .loc 3 510 0
 1915 0032 FB68     	 ldr r3,[r7,#12]
 1916 0034 3B61     	 str r3,[r7,#16]
 511:../main.c     **** 		if (!strcmp(cmd, "Send"))
 1917              	 .loc 3 511 0
 1918 0036 3869     	 ldr r0,[r7,#16]
 1919 0038 2449     	 ldr r1,.L115+4
 1920 003a FFF7FEFF 	 bl strcmp
 1921 003e 0346     	 mov r3,r0
 1922 0040 002B     	 cmp r3,#0
 1923 0042 06D1     	 bne .L108
 512:../main.c     **** 		{
 513:../main.c     **** 			result = processSendCommand(commandLine);
 1924              	 .loc 3 513 0
 1925 0044 BB68     	 ldr r3,[r7,#8]
 1926 0046 1846     	 mov r0,r3
 1927 0048 FFF7FEFF 	 bl processSendCommand
 1928 004c 0346     	 mov r3,r0
 1929 004e FB75     	 strb r3,[r7,#23]
 1930 0050 2BE0     	 b .L109
 1931              	.L108:
 514:../main.c     **** 		}
 515:../main.c     **** 		else if (!strcmp(cmd, "Echo"))
 1932              	 .loc 3 515 0
 1933 0052 3869     	 ldr r0,[r7,#16]
 1934 0054 1E49     	 ldr r1,.L115+8
 1935 0056 FFF7FEFF 	 bl strcmp
 1936 005a 0346     	 mov r3,r0
 1937 005c 002B     	 cmp r3,#0
 1938 005e 06D1     	 bne .L110
 516:../main.c     **** 		{
 517:../main.c     **** 			result = processEchoCommand(commandLine);
 1939              	 .loc 3 517 0
 1940 0060 BB68     	 ldr r3,[r7,#8]
 1941 0062 1846     	 mov r0,r3
 1942 0064 FFF7FEFF 	 bl processEchoCommand
 1943 0068 0346     	 mov r3,r0
 1944 006a FB75     	 strb r3,[r7,#23]
 1945 006c 1DE0     	 b .L109
 1946              	.L110:
 518:../main.c     **** 		}
 519:../main.c     **** 		else if (!strcmp(cmd, "Surge"))
 1947              	 .loc 3 519 0
 1948 006e 3869     	 ldr r0,[r7,#16]
 1949 0070 1849     	 ldr r1,.L115+12
 1950 0072 FFF7FEFF 	 bl strcmp
 1951 0076 0346     	 mov r3,r0
 1952 0078 002B     	 cmp r3,#0
 1953 007a 04D1     	 bne .L111
 520:../main.c     **** 		{
 521:../main.c     **** 			result = processSurgeCommand();
 1954              	 .loc 3 521 0
 1955 007c FFF7FEFF 	 bl processSurgeCommand
 1956 0080 0346     	 mov r3,r0
 1957 0082 FB75     	 strb r3,[r7,#23]
 1958 0084 11E0     	 b .L109
 1959              	.L111:
 522:../main.c     **** 		}
 523:../main.c     **** 		else if (!strcmp(cmd, "Analyzer"))
 1960              	 .loc 3 523 0
 1961 0086 3869     	 ldr r0,[r7,#16]
 1962 0088 1349     	 ldr r1,.L115+16
 1963 008a FFF7FEFF 	 bl strcmp
 1964 008e 0346     	 mov r3,r0
 1965 0090 002B     	 cmp r3,#0
 1966 0092 06D1     	 bne .L112
 524:../main.c     **** 		{
 525:../main.c     **** 			result = processAnalyzerCommand(commandLine);
 1967              	 .loc 3 525 0
 1968 0094 BB68     	 ldr r3,[r7,#8]
 1969 0096 1846     	 mov r0,r3
 1970 0098 FFF7FEFF 	 bl processAnalyzerCommand
 1971 009c 0346     	 mov r3,r0
 1972 009e FB75     	 strb r3,[r7,#23]
 1973 00a0 03E0     	 b .L109
 1974              	.L112:
 526:../main.c     **** 		}
 527:../main.c     **** 		else
 528:../main.c     **** 		{
 529:../main.c     **** 			USB_CAN_printf("\r\nUnknown command '%s'\r\n", cmd);
 1975              	 .loc 3 529 0
 1976 00a2 0E48     	 ldr r0,.L115+20
 1977 00a4 3969     	 ldr r1,[r7,#16]
 1978 00a6 FFF7FEFF 	 bl USB_CAN_printf
 1979              	.L109:
 530:../main.c     **** 		}
 531:../main.c     **** 
 532:../main.c     **** 		if (result == USB_CAN_STATUS_SUCCESS)
 1980              	 .loc 3 532 0
 1981 00aa FB7D     	 ldrb r3,[r7,#23]
 1982 00ac 002B     	 cmp r3,#0
 1983 00ae 03D1     	 bne .L113
 533:../main.c     **** 		{
 534:../main.c     **** 			USB_CAN_printf("\r\nResult: Success\r\n");
 1984              	 .loc 3 534 0
 1985 00b0 0B48     	 ldr r0,.L115+24
 1986 00b2 FFF7FEFF 	 bl USB_CAN_printf
 1987 00b6 02E0     	 b .L107
 1988              	.L113:
 535:../main.c     **** 		}
 536:../main.c     **** 		else
 537:../main.c     **** 		{
 538:../main.c     **** 			USB_CAN_printf("\r\nResult: Failure\r\n");
 1989              	 .loc 3 538 0
 1990 00b8 0A48     	 ldr r0,.L115+28
 1991 00ba FFF7FEFF 	 bl USB_CAN_printf
 1992              	.L107:
 539:../main.c     **** 		}
 540:../main.c     **** 	}
 541:../main.c     **** 	return result;
 1993              	 .loc 3 541 0
 1994 00be FB7D     	 ldrb r3,[r7,#23]
 1995              	.L114:
 542:../main.c     **** }
 1996              	 .loc 3 542 0 discriminator 1
 1997 00c0 1846     	 mov r0,r3
 1998 00c2 1837     	 adds r7,r7,#24
 1999              	.LCFI130:
 2000              	 .cfi_def_cfa_offset 8
 2001 00c4 BD46     	 mov sp,r7
 2002              	.LCFI131:
 2003              	 .cfi_def_cfa_register 13
 2004              	 
 2005 00c6 80BD     	 pop {r7,pc}
 2006              	.L116:
 2007              	 .align 2
 2008              	.L115:
 2009 00c8 00000000 	 .word CommandSeperator
 2010 00cc 40000000 	 .word .LC8
 2011 00d0 48000000 	 .word .LC9
 2012 00d4 50000000 	 .word .LC10
 2013 00d8 58000000 	 .word .LC11
 2014 00dc 64000000 	 .word .LC12
 2015 00e0 80000000 	 .word .LC13
 2016 00e4 94000000 	 .word .LC14
 2017              	 .cfi_endproc
 2018              	.LFE260:
 2020              	 .section .rodata
 2021              	 .align 2
 2022              	.LC15:
 2023 00a8 0D3E2025 	 .ascii "\015> %s\000"
 2023      7300
 2024              	 .section .text.USBD_VCOM_SendPromt,"ax",%progbits
 2025              	 .align 2
 2026              	 .global USBD_VCOM_SendPromt
 2027              	 .thumb
 2028              	 .thumb_func
 2030              	USBD_VCOM_SendPromt:
 2031              	.LFB261:
 543:../main.c     **** 
 544:../main.c     **** USBD_VCOM_STATUS_t USBD_VCOM_SendPromt(int8_t usb_rx_buffer[])
 545:../main.c     **** {
 2032              	 .loc 3 545 0
 2033              	 .cfi_startproc
 2034              	 
 2035              	 
 2036 0000 80B5     	 push {r7,lr}
 2037              	.LCFI132:
 2038              	 .cfi_def_cfa_offset 8
 2039              	 .cfi_offset 7,-8
 2040              	 .cfi_offset 14,-4
 2041 0002 82B0     	 sub sp,sp,#8
 2042              	.LCFI133:
 2043              	 .cfi_def_cfa_offset 16
 2044 0004 00AF     	 add r7,sp,#0
 2045              	.LCFI134:
 2046              	 .cfi_def_cfa_register 7
 2047 0006 7860     	 str r0,[r7,#4]
 546:../main.c     **** 	return USB_CAN_printf("\r> %s", usb_rx_buffer);
 2048              	 .loc 3 546 0
 2049 0008 0448     	 ldr r0,.L119
 2050 000a 7968     	 ldr r1,[r7,#4]
 2051 000c FFF7FEFF 	 bl USB_CAN_printf
 2052 0010 0346     	 mov r3,r0
 547:../main.c     **** }
 2053              	 .loc 3 547 0
 2054 0012 1846     	 mov r0,r3
 2055 0014 0837     	 adds r7,r7,#8
 2056              	.LCFI135:
 2057              	 .cfi_def_cfa_offset 8
 2058 0016 BD46     	 mov sp,r7
 2059              	.LCFI136:
 2060              	 .cfi_def_cfa_register 13
 2061              	 
 2062 0018 80BD     	 pop {r7,pc}
 2063              	.L120:
 2064 001a 00BF     	 .align 2
 2065              	.L119:
 2066 001c A8000000 	 .word .LC15
 2067              	 .cfi_endproc
 2068              	.LFE261:
 2070              	 .section .text.processTrigger,"ax",%progbits
 2071              	 .align 2
 2072              	 .global processTrigger
 2073              	 .thumb
 2074              	 .thumb_func
 2076              	processTrigger:
 2077              	.LFB262:
 548:../main.c     **** 
 549:../main.c     **** USBD_VCOM_STATUS_t processTrigger(XMC_CAN_MO_t* message,
 550:../main.c     **** 		SendCommand_t *sendCommand)
 551:../main.c     **** {
 2078              	 .loc 3 551 0
 2079              	 .cfi_startproc
 2080              	 
 2081              	 
 2082              	 
 2083 0000 80B4     	 push {r7}
 2084              	.LCFI137:
 2085              	 .cfi_def_cfa_offset 4
 2086              	 .cfi_offset 7,-4
 2087 0002 85B0     	 sub sp,sp,#20
 2088              	.LCFI138:
 2089              	 .cfi_def_cfa_offset 24
 2090 0004 00AF     	 add r7,sp,#0
 2091              	.LCFI139:
 2092              	 .cfi_def_cfa_register 7
 2093 0006 7860     	 str r0,[r7,#4]
 2094 0008 3960     	 str r1,[r7]
 552:../main.c     **** 	if (message == NULL)
 2095              	 .loc 3 552 0
 2096 000a 7B68     	 ldr r3,[r7,#4]
 2097 000c 002B     	 cmp r3,#0
 2098 000e 01D1     	 bne .L122
 553:../main.c     **** 	{
 554:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 2099              	 .loc 3 554 0
 2100 0010 0123     	 movs r3,#1
 2101 0012 3BE0     	 b .L123
 2102              	.L122:
 555:../main.c     **** 	}
 556:../main.c     **** 
 557:../main.c     **** 	if (sendCommand == NULL)
 2103              	 .loc 3 557 0
 2104 0014 3B68     	 ldr r3,[r7]
 2105 0016 002B     	 cmp r3,#0
 2106 0018 01D1     	 bne .L124
 558:../main.c     **** 	{
 559:../main.c     **** 		return USB_CAN_STATUS_FAILURE;
 2107              	 .loc 3 559 0
 2108 001a 0123     	 movs r3,#1
 2109 001c 36E0     	 b .L123
 2110              	.L124:
 560:../main.c     **** 	}
 561:../main.c     **** 
 562:../main.c     **** 	if (sendCommand->trigger.is_valid)
 2111              	 .loc 3 562 0
 2112 001e 3B68     	 ldr r3,[r7]
 2113 0020 5B7A     	 ldrb r3,[r3,#9]
 2114 0022 002B     	 cmp r3,#0
 2115 0024 31D0     	 beq .L125
 563:../main.c     **** 	{
 564:../main.c     **** 		if (sendCommand->trigger.can_identifier == message->can_identifier)
 2116              	 .loc 3 564 0
 2117 0026 3B68     	 ldr r3,[r7]
 2118 0028 5B68     	 ldr r3,[r3,#4]
 2119 002a 7A68     	 ldr r2,[r7,#4]
 2120 002c 5268     	 ldr r2,[r2,#4]
 2121 002e C2F31C02 	 ubfx r2,r2,#0,#29
 2122 0032 9342     	 cmp r3,r2
 2123 0034 29D1     	 bne .L125
 2124              	.LBB7:
 565:../main.c     **** 		{
 566:../main.c     **** 			int bitNumber = sendCommand->trigger.can_bit % 8;
 2125              	 .loc 3 566 0
 2126 0036 3B68     	 ldr r3,[r7]
 2127 0038 1B7A     	 ldrb r3,[r3,#8]
 2128 003a 03F00703 	 and r3,r3,#7
 2129 003e FB60     	 str r3,[r7,#12]
 567:../main.c     **** 			int byteNumber = (sendCommand->trigger.can_bit % 63) / 8;
 2130              	 .loc 3 567 0
 2131 0040 3B68     	 ldr r3,[r7]
 2132 0042 1A7A     	 ldrb r2,[r3,#8]
 2133 0044 144B     	 ldr r3,.L127
 2134 0046 A2FB0301 	 umull r0,r1,r2,r3
 2135 004a 531A     	 subs r3,r2,r1
 2136 004c 5B08     	 lsrs r3,r3,#1
 2137 004e 0B44     	 add r3,r3,r1
 2138 0050 5909     	 lsrs r1,r3,#5
 2139 0052 0B46     	 mov r3,r1
 2140 0054 9B01     	 lsls r3,r3,#6
 2141 0056 5B1A     	 subs r3,r3,r1
 2142 0058 D31A     	 subs r3,r2,r3
 2143 005a DBB2     	 uxtb r3,r3
 2144 005c DB08     	 lsrs r3,r3,#3
 2145 005e DBB2     	 uxtb r3,r3
 2146 0060 BB60     	 str r3,[r7,#8]
 568:../main.c     **** 			if ((message->can_data_byte[byteNumber] >> bitNumber) & 0x1)
 2147              	 .loc 3 568 0
 2148 0062 7A68     	 ldr r2,[r7,#4]
 2149 0064 BB68     	 ldr r3,[r7,#8]
 2150 0066 1344     	 add r3,r3,r2
 2151 0068 1033     	 adds r3,r3,#16
 2152 006a 1B78     	 ldrb r3,[r3]
 2153 006c 1A46     	 mov r2,r3
 2154 006e FB68     	 ldr r3,[r7,#12]
 2155 0070 42FA03F3 	 asr r3,r2,r3
 2156 0074 03F00103 	 and r3,r3,#1
 2157 0078 002B     	 cmp r3,#0
 2158 007a 03D0     	 beq .L126
 569:../main.c     **** 			{
 570:../main.c     **** 				sendCommand->condition = Condition_Active;
 2159              	 .loc 3 570 0
 2160 007c 3B68     	 ldr r3,[r7]
 2161 007e 0122     	 movs r2,#1
 2162 0080 1A70     	 strb r2,[r3]
 2163 0082 02E0     	 b .L125
 2164              	.L126:
 571:../main.c     **** 			}
 572:../main.c     **** 			else
 573:../main.c     **** 			{
 574:../main.c     **** 				sendCommand->condition = Condition_Passive;
 2165              	 .loc 3 574 0
 2166 0084 3B68     	 ldr r3,[r7]
 2167 0086 0022     	 movs r2,#0
 2168 0088 1A70     	 strb r2,[r3]
 2169              	.L125:
 2170              	.LBE7:
 575:../main.c     **** 			}
 576:../main.c     **** 		}
 577:../main.c     **** 	}
 578:../main.c     **** 
 579:../main.c     **** 	return USB_CAN_STATUS_SUCCESS;
 2171              	 .loc 3 579 0
 2172 008a 0023     	 movs r3,#0
 2173              	.L123:
 580:../main.c     **** }
 2174              	 .loc 3 580 0
 2175 008c 1846     	 mov r0,r3
 2176 008e 1437     	 adds r7,r7,#20
 2177              	.LCFI140:
 2178              	 .cfi_def_cfa_offset 4
 2179 0090 BD46     	 mov sp,r7
 2180              	.LCFI141:
 2181              	 .cfi_def_cfa_register 13
 2182              	 
 2183 0092 5DF8047B 	 ldr r7,[sp],#4
 2184              	.LCFI142:
 2185              	 .cfi_restore 7
 2186              	 .cfi_def_cfa_offset 0
 2187 0096 7047     	 bx lr
 2188              	.L128:
 2189              	 .align 2
 2190              	.L127:
 2191 0098 05411004 	 .word 68174085
 2192              	 .cfi_endproc
 2193              	.LFE262:
 2195              	 .section .rodata
 2196 00ae 0000     	 .align 2
 2197              	.LC16:
 2198 00b0 0D0A5265 	 .ascii "\015\012Result: Failure sending CAN\015\012\000"
 2198      73756C74 
 2198      3A204661 
 2198      696C7572 
 2198      65207365 
 2199              	 .align 2
 2200              	.LC17:
 2201 00d0 0D0A4163 	 .ascii "\015\012Activation by button\015\012\000"
 2201      74697661 
 2201      74696F6E 
 2201      20627920 
 2201      62757474 
 2202 00e9 000000   	 .align 2
 2203              	.LC18:
 2204 00ec 0D0A4465 	 .ascii "\015\012Deactivation by button\015\012\000"
 2204      61637469 
 2204      76617469 
 2204      6F6E2062 
 2204      79206275 
 2205 0107 00       	 .section .text.main,"ax",%progbits
 2206              	 .align 2
 2207              	 .global main
 2208              	 .thumb
 2209              	 .thumb_func
 2211              	main:
 2212              	.LFB263:
 581:../main.c     **** 
 582:../main.c     **** int main(void)
 583:../main.c     **** {
 2213              	 .loc 3 583 0
 2214              	 .cfi_startproc
 2215              	 
 2216              	 
 2217 0000 80B5     	 push {r7,lr}
 2218              	.LCFI143:
 2219              	 .cfi_def_cfa_offset 8
 2220              	 .cfi_offset 7,-8
 2221              	 .cfi_offset 14,-4
 2222 0002 88B0     	 sub sp,sp,#32
 2223              	.LCFI144:
 2224              	 .cfi_def_cfa_offset 40
 2225 0004 00AF     	 add r7,sp,#0
 2226              	.LCFI145:
 2227              	 .cfi_def_cfa_register 7
 584:../main.c     **** 	const uint32_t Button_NotPressed = 1;
 2228              	 .loc 3 584 0
 2229 0006 0123     	 movs r3,#1
 2230 0008 7B61     	 str r3,[r7,#20]
 585:../main.c     **** 	uint32_t Button1OldValue = Button_NotPressed;
 2231              	 .loc 3 585 0
 2232 000a 7B69     	 ldr r3,[r7,#20]
 2233 000c FB61     	 str r3,[r7,#28]
 586:../main.c     **** 
 587:../main.c     **** #ifdef XMC_DEBUG_ENABLE
 588:../main.c     **** 	/* TODO check influence on USBD_VCOM */
 589:../main.c     **** 	initialise_monitor_handles();
 590:../main.c     **** #endif
 591:../main.c     **** 
 592:../main.c     **** 	info("Initializing ...");
 593:../main.c     **** 
 594:../main.c     **** 	assert(DAVE_Init() != DAVE_STATUS_FAILURE);
 2234              	 .loc 3 594 0
 2235 000e FFF7FEFF 	 bl DAVE_Init
 2236 0012 0346     	 mov r3,r0
 2237 0014 012B     	 cmp r3,#1
 2238 0016 01D1     	 bne .L130
 2239              	 .loc 3 594 0 is_stmt 0 discriminator 1
 2240 0018 FFF7FEFF 	 bl _error
 2241              	.L130:
 595:../main.c     **** 
 596:../main.c     **** 	// Set LED pins to push-pull
 597:../main.c     **** 	XMC_GPIO_SetMode(LED_INFO, XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
 2242              	 .loc 3 597 0 is_stmt 1
 2243 001c 5F48     	 ldr r0,.L145
 2244 001e 0921     	 movs r1,#9
 2245 0020 8022     	 movs r2,#128
 2246 0022 FFF7FEFF 	 bl XMC_GPIO_SetMode
 598:../main.c     **** 	XMC_GPIO_SetMode(LED_ERROR, XMC_GPIO_MODE_OUTPUT_PUSH_PULL);
 2247              	 .loc 3 598 0
 2248 0026 5D48     	 ldr r0,.L145
 2249 0028 0821     	 movs r1,#8
 2250 002a 8022     	 movs r2,#128
 2251 002c FFF7FEFF 	 bl XMC_GPIO_SetMode
 599:../main.c     **** 	XMC_GPIO_EnableDigitalInput(BUTTON1);
 2252              	 .loc 3 599 0
 2253 0030 5B48     	 ldr r0,.L145+4
 2254 0032 0D21     	 movs r1,#13
 2255 0034 FFF7FEFF 	 bl XMC_GPIO_EnableDigitalInput
 600:../main.c     **** 
 601:../main.c     **** 	// Switch off LEDs
 602:../main.c     **** 	XMC_GPIO_SetOutputLow(LED_INFO);
 2256              	 .loc 3 602 0
 2257 0038 5848     	 ldr r0,.L145
 2258 003a 0921     	 movs r1,#9
 2259 003c FFF7FEFF 	 bl XMC_GPIO_SetOutputLow
 603:../main.c     **** 	XMC_GPIO_SetOutputLow(LED_ERROR);
 2260              	 .loc 3 603 0
 2261 0040 5648     	 ldr r0,.L145
 2262 0042 0821     	 movs r1,#8
 2263 0044 FFF7FEFF 	 bl XMC_GPIO_SetOutputLow
 604:../main.c     **** 
 605:../main.c     **** 	assert(USBD_VCOM_Connect() == USBD_VCOM_STATUS_SUCCESS)
 2264              	 .loc 3 605 0
 2265 0048 FFF7FEFF 	 bl USBD_VCOM_Connect
 2266 004c 0346     	 mov r3,r0
 2267 004e 002B     	 cmp r3,#0
 2268 0050 01D0     	 beq .L131
 2269              	 .loc 3 605 0 is_stmt 0 discriminator 1
 2270 0052 FFF7FEFF 	 bl _error
 2271              	.L131:
 606:../main.c     **** 
 607:../main.c     **** 	XMC_GPIO_SetOutputHigh(LED_ERROR);
 2272              	 .loc 3 607 0 is_stmt 1
 2273 0056 5148     	 ldr r0,.L145
 2274 0058 0821     	 movs r1,#8
 2275 005a FFF7FEFF 	 bl XMC_GPIO_SetOutputHigh
 608:../main.c     **** 	while (!USBD_VCOM_IsEnumDone())
 2276              	 .loc 3 608 0
 2277 005e 00BF     	 nop
 2278              	.L132:
 2279              	 .loc 3 608 0 is_stmt 0 discriminator 1
 2280 0060 FFF7FEFF 	 bl USBD_VCOM_IsEnumDone
 2281 0064 0346     	 mov r3,r0
 2282 0066 002B     	 cmp r3,#0
 2283 0068 FAD0     	 beq .L132
 609:../main.c     **** 		;
 610:../main.c     **** 	XMC_GPIO_SetOutputLow(LED_ERROR);
 2284              	 .loc 3 610 0 is_stmt 1
 2285 006a 4C48     	 ldr r0,.L145
 2286 006c 0821     	 movs r1,#8
 2287 006e FFF7FEFF 	 bl XMC_GPIO_SetOutputLow
 611:../main.c     **** 
 612:../main.c     **** 	info("Initializing ... done.");
 613:../main.c     **** 
 614:../main.c     **** 	USBD_VCOM_SendPromt(usb_rx_buffer);
 2288              	 .loc 3 614 0
 2289 0072 4C48     	 ldr r0,.L145+8
 2290 0074 FFF7FEFF 	 bl USBD_VCOM_SendPromt
 615:../main.c     **** 
 616:../main.c     **** 	int usb_rx_buffer_idx = 0;
 2291              	 .loc 3 616 0
 2292 0078 0023     	 movs r3,#0
 2293 007a BB61     	 str r3,[r7,#24]
 2294              	.L144:
 617:../main.c     **** 	while (1U)
 618:../main.c     **** 	{
 619:../main.c     **** 		/* consume only last received message, discard other received messages */
 620:../main.c     **** 		if (ReceivedMsg != NULL)
 2295              	 .loc 3 620 0
 2296 007c 4A4B     	 ldr r3,.L145+12
 2297 007e 1B68     	 ldr r3,[r3]
 2298 0080 002B     	 cmp r3,#0
 2299 0082 08D0     	 beq .L133
 2300              	.LBB8:
 621:../main.c     **** 		{
 622:../main.c     **** 			XMC_CAN_MO_t* tmp = ReceivedMsg;
 2301              	 .loc 3 622 0
 2302 0084 484B     	 ldr r3,.L145+12
 2303 0086 1B68     	 ldr r3,[r3]
 2304 0088 3B61     	 str r3,[r7,#16]
 623:../main.c     **** 			ReceivedMsg = NULL;
 2305              	 .loc 3 623 0
 2306 008a 474B     	 ldr r3,.L145+12
 2307 008c 0022     	 movs r2,#0
 2308 008e 1A60     	 str r2,[r3]
 624:../main.c     **** 
 625:../main.c     **** 			consumeCanMsg(tmp);
 2309              	 .loc 3 625 0
 2310 0090 3869     	 ldr r0,[r7,#16]
 2311 0092 FFF7FEFF 	 bl consumeCanMsg
 2312              	.L133:
 2313              	.LBE8:
 626:../main.c     **** 		}
 627:../main.c     **** 
 628:../main.c     **** 		if (executeSendCommand(&SendCommand) != USB_CAN_STATUS_SUCCESS)
 2314              	 .loc 3 628 0
 2315 0096 4548     	 ldr r0,.L145+16
 2316 0098 FFF7FEFF 	 bl executeSendCommand
 2317 009c 0346     	 mov r3,r0
 2318 009e 002B     	 cmp r3,#0
 2319 00a0 02D0     	 beq .L134
 629:../main.c     **** 		{
 630:../main.c     **** 			USB_CAN_printf("\r\nResult: Failure sending CAN\r\n");
 2320              	 .loc 3 630 0
 2321 00a2 4348     	 ldr r0,.L145+20
 2322 00a4 FFF7FEFF 	 bl USB_CAN_printf
 2323              	.L134:
 2324              	.LBB9:
 631:../main.c     **** 		}
 632:../main.c     **** 
 633:../main.c     **** 		{
 634:../main.c     **** 			uint32_t Button1Value = XMC_GPIO_GetInput(BUTTON1);
 2325              	 .loc 3 634 0
 2326 00a8 3D48     	 ldr r0,.L145+4
 2327 00aa 0D21     	 movs r1,#13
 2328 00ac FFF7FEFF 	 bl XMC_GPIO_GetInput
 2329 00b0 F860     	 str r0,[r7,#12]
 635:../main.c     **** 
 636:../main.c     **** 			/* react on edge */
 637:../main.c     **** 			if ((Button1Value != Button_NotPressed)
 2330              	 .loc 3 637 0
 2331 00b2 FA68     	 ldr r2,[r7,#12]
 2332 00b4 7B69     	 ldr r3,[r7,#20]
 2333 00b6 9A42     	 cmp r2,r3
 2334 00b8 14D0     	 beq .L135
 638:../main.c     **** 					&& (Button1Value != Button1OldValue))
 2335              	 .loc 3 638 0
 2336 00ba FA68     	 ldr r2,[r7,#12]
 2337 00bc FB69     	 ldr r3,[r7,#28]
 2338 00be 9A42     	 cmp r2,r3
 2339 00c0 10D0     	 beq .L135
 639:../main.c     **** 
 640:../main.c     **** 			{
 641:../main.c     **** 				if (SendCommand.condition != Condition_Active)
 2340              	 .loc 3 641 0
 2341 00c2 3A4B     	 ldr r3,.L145+16
 2342 00c4 1B78     	 ldrb r3,[r3]
 2343 00c6 012B     	 cmp r3,#1
 2344 00c8 06D0     	 beq .L136
 642:../main.c     **** 				{
 643:../main.c     **** 					SendCommand.condition = Condition_Active;
 2345              	 .loc 3 643 0
 2346 00ca 384B     	 ldr r3,.L145+16
 2347 00cc 0122     	 movs r2,#1
 2348 00ce 1A70     	 strb r2,[r3]
 644:../main.c     **** 					USB_CAN_printf("\r\nActivation by button\r\n");
 2349              	 .loc 3 644 0
 2350 00d0 3848     	 ldr r0,.L145+24
 2351 00d2 FFF7FEFF 	 bl USB_CAN_printf
 2352 00d6 05E0     	 b .L135
 2353              	.L136:
 645:../main.c     **** 				}
 646:../main.c     **** 				else
 647:../main.c     **** 				{
 648:../main.c     **** 					SendCommand.condition = Condition_Passive;
 2354              	 .loc 3 648 0
 2355 00d8 344B     	 ldr r3,.L145+16
 2356 00da 0022     	 movs r2,#0
 2357 00dc 1A70     	 strb r2,[r3]
 649:../main.c     **** 					USB_CAN_printf("\r\nDeactivation by button\r\n");
 2358              	 .loc 3 649 0
 2359 00de 3648     	 ldr r0,.L145+28
 2360 00e0 FFF7FEFF 	 bl USB_CAN_printf
 2361              	.L135:
 650:../main.c     **** 				}
 651:../main.c     **** 			}
 652:../main.c     **** 			Button1OldValue = Button1Value;
 2362              	 .loc 3 652 0
 2363 00e4 FB68     	 ldr r3,[r7,#12]
 2364 00e6 FB61     	 str r3,[r7,#28]
 2365              	.LBE9:
 2366              	.LBB10:
 653:../main.c     **** 		}
 654:../main.c     **** 
 655:../main.c     **** 		{
 656:../main.c     **** 			uint16_t bytesReceived = USBD_VCOM_BytesReceived();
 2367              	 .loc 3 656 0
 2368 00e8 FFF7FEFF 	 bl USBD_VCOM_BytesReceived
 2369 00ec 0346     	 mov r3,r0
 2370 00ee 7B81     	 strh r3,[r7,#10]
 657:../main.c     **** 
 658:../main.c     **** 			if (bytesReceived)
 2371              	 .loc 3 658 0
 2372 00f0 7B89     	 ldrh r3,[r7,#10]
 2373 00f2 002B     	 cmp r3,#0
 2374 00f4 4AD0     	 beq .L137
 2375              	.LBB11:
 659:../main.c     **** 			{
 660:../main.c     **** 				USBD_VCOM_STATUS_t status;
 661:../main.c     **** 				int8_t data_byte = 0;
 2376              	 .loc 3 661 0
 2377 00f6 0023     	 movs r3,#0
 2378 00f8 FB71     	 strb r3,[r7,#7]
 662:../main.c     **** 				const int8_t newLine = '\r';
 2379              	 .loc 3 662 0
 2380 00fa 0D23     	 movs r3,#13
 2381 00fc 7B72     	 strb r3,[r7,#9]
 663:../main.c     **** 				status = USBD_VCOM_ReceiveByte(&data_byte);
 2382              	 .loc 3 663 0
 2383 00fe FB1D     	 adds r3,r7,#7
 2384 0100 1846     	 mov r0,r3
 2385 0102 FFF7FEFF 	 bl USBD_VCOM_ReceiveByte
 2386 0106 0346     	 mov r3,r0
 2387 0108 3B72     	 strb r3,[r7,#8]
 664:../main.c     **** 				if (status == USBD_VCOM_STATUS_SUCCESS)
 2388              	 .loc 3 664 0
 2389 010a 3B7A     	 ldrb r3,[r7,#8]
 2390 010c 002B     	 cmp r3,#0
 2391 010e 3DD1     	 bne .L137
 665:../main.c     **** 				{
 666:../main.c     **** 					if (data_byte == newLine)
 2392              	 .loc 3 666 0
 2393 0110 FB79     	 ldrb r3,[r7,#7]
 2394 0112 97F90920 	 ldrsb r2,[r7,#9]
 2395 0116 5BB2     	 sxtb r3,r3
 2396 0118 9A42     	 cmp r2,r3
 2397 011a 0BD1     	 bne .L139
 667:../main.c     **** 					{
 668:../main.c     **** 						processCommand(usb_rx_buffer);
 2398              	 .loc 3 668 0
 2399 011c 2148     	 ldr r0,.L145+8
 2400 011e FFF7FEFF 	 bl processCommand
 669:../main.c     **** 
 670:../main.c     **** 						usb_rx_buffer_idx = 0;
 2401              	 .loc 3 670 0
 2402 0122 0023     	 movs r3,#0
 2403 0124 BB61     	 str r3,[r7,#24]
 671:../main.c     **** 						memset(usb_rx_buffer, 0, USBD_VCOM_BUFFSIZE);
 2404              	 .loc 3 671 0
 2405 0126 1F48     	 ldr r0,.L145+8
 2406 0128 0021     	 movs r1,#0
 2407 012a 4FF48072 	 mov r2,#256
 2408 012e FFF7FEFF 	 bl memset
 2409 0132 28E0     	 b .L140
 2410              	.L139:
 672:../main.c     **** 					}
 673:../main.c     **** 					else if (data_byte == '\177')
 2411              	 .loc 3 673 0
 2412 0134 FB79     	 ldrb r3,[r7,#7]
 2413 0136 5BB2     	 sxtb r3,r3
 2414 0138 7F2B     	 cmp r3,#127
 2415 013a 13D1     	 bne .L141
 674:../main.c     **** 					{
 675:../main.c     **** 						if (usb_rx_buffer_idx > 0)
 2416              	 .loc 3 675 0
 2417 013c BB69     	 ldr r3,[r7,#24]
 2418 013e 002B     	 cmp r3,#0
 2419 0140 21DD     	 ble .L140
 676:../main.c     **** 						{
 677:../main.c     **** 							usb_rx_buffer_idx--;
 2420              	 .loc 3 677 0
 2421 0142 BB69     	 ldr r3,[r7,#24]
 2422 0144 013B     	 subs r3,r3,#1
 2423 0146 BB61     	 str r3,[r7,#24]
 678:../main.c     **** 							usb_rx_buffer[usb_rx_buffer_idx] = ' ';
 2424              	 .loc 3 678 0
 2425 0148 164A     	 ldr r2,.L145+8
 2426 014a BB69     	 ldr r3,[r7,#24]
 2427 014c 1344     	 add r3,r3,r2
 2428 014e 2022     	 movs r2,#32
 2429 0150 1A70     	 strb r2,[r3]
 679:../main.c     **** 							USBD_VCOM_SendPromt(usb_rx_buffer);
 2430              	 .loc 3 679 0
 2431 0152 1448     	 ldr r0,.L145+8
 2432 0154 FFF7FEFF 	 bl USBD_VCOM_SendPromt
 680:../main.c     **** 							usb_rx_buffer[usb_rx_buffer_idx] = 0;
 2433              	 .loc 3 680 0
 2434 0158 124A     	 ldr r2,.L145+8
 2435 015a BB69     	 ldr r3,[r7,#24]
 2436 015c 1344     	 add r3,r3,r2
 2437 015e 0022     	 movs r2,#0
 2438 0160 1A70     	 strb r2,[r3]
 2439 0162 10E0     	 b .L140
 2440              	.L141:
 681:../main.c     **** 						}
 682:../main.c     **** 					}
 683:../main.c     **** 					else if (is_printable(data_byte)
 2441              	 .loc 3 683 0
 2442 0164 FB79     	 ldrb r3,[r7,#7]
 2443 0166 5BB2     	 sxtb r3,r3
 2444 0168 1846     	 mov r0,r3
 2445 016a FFF7FEFF 	 bl is_printable
 2446 016e 0346     	 mov r3,r0
 2447 0170 002B     	 cmp r3,#0
 2448 0172 08D0     	 beq .L140
 684:../main.c     **** 							&& (usb_rx_buffer_idx < (USBD_VCOM_BUFFSIZE - 1)))
 2449              	 .loc 3 684 0
 2450 0174 BB69     	 ldr r3,[r7,#24]
 2451 0176 FE2B     	 cmp r3,#254
 2452 0178 05DC     	 bgt .L140
 685:../main.c     **** 					{
 686:../main.c     **** 						usb_rx_buffer[usb_rx_buffer_idx++] = data_byte;
 2453              	 .loc 3 686 0
 2454 017a BB69     	 ldr r3,[r7,#24]
 2455 017c 5A1C     	 adds r2,r3,#1
 2456 017e BA61     	 str r2,[r7,#24]
 2457 0180 F979     	 ldrb r1,[r7,#7]
 2458 0182 084A     	 ldr r2,.L145+8
 2459 0184 D154     	 strb r1,[r2,r3]
 2460              	.L140:
 687:../main.c     **** 					}
 688:../main.c     **** 					USBD_VCOM_SendPromt(usb_rx_buffer);
 2461              	 .loc 3 688 0
 2462 0186 0748     	 ldr r0,.L145+8
 2463 0188 FFF7FEFF 	 bl USBD_VCOM_SendPromt
 2464              	.L137:
 2465              	.LBE11:
 689:../main.c     **** 				}
 690:../main.c     **** 			}
 691:../main.c     **** 
 692:../main.c     **** 			/* Do not spend time in USBTask during flooding the CAN */
 693:../main.c     **** 			if (SendCommand.condition != Condition_Active)
 2466              	 .loc 3 693 0
 2467 018c 074B     	 ldr r3,.L145+16
 2468 018e 1B78     	 ldrb r3,[r3]
 2469 0190 012B     	 cmp r3,#1
 2470 0192 02D0     	 beq .L143
 694:../main.c     **** 			{
 695:../main.c     **** 				CDC_Device_USBTask(&USBD_VCOM_cdc_interface);
 2471              	 .loc 3 695 0
 2472 0194 0948     	 ldr r0,.L145+32
 2473 0196 FFF7FEFF 	 bl CDC_Device_USBTask
 2474              	.L143:
 2475              	.LBE10:
 696:../main.c     **** 			}
 697:../main.c     **** 		}
 698:../main.c     **** 	}
 2476              	 .loc 3 698 0
 2477 019a 6FE7     	 b .L144
 2478              	.L146:
 2479              	 .align 2
 2480              	.L145:
 2481 019c 00850248 	 .word 1208124672
 2482 01a0 008F0248 	 .word 1208127232
 2483 01a4 00000000 	 .word usb_rx_buffer
 2484 01a8 00000000 	 .word ReceivedMsg
 2485 01ac 00000000 	 .word SendCommand
 2486 01b0 B0000000 	 .word .LC16
 2487 01b4 D0000000 	 .word .LC17
 2488 01b8 EC000000 	 .word .LC18
 2489 01bc 00000000 	 .word USBD_VCOM_cdc_interface
 2490              	 .cfi_endproc
 2491              	.LFE263:
 2493              	 .section .text.CAN0_1_IRQHandler,"ax",%progbits
 2494              	 .align 2
 2495              	 .global CAN0_1_IRQHandler
 2496              	 .thumb
 2497              	 .thumb_func
 2499              	CAN0_1_IRQHandler:
 2500              	.LFB264:
 699:../main.c     **** 
 700:../main.c     **** 	error("never reach here");
 701:../main.c     **** }
 702:../main.c     **** 
 703:../main.c     **** void CanRxInterruptHandler(void)
 704:../main.c     **** {
 2501              	 .loc 3 704 0
 2502              	 .cfi_startproc
 2503              	 
 2504              	 
 2505 0000 80B5     	 push {r7,lr}
 2506              	.LCFI146:
 2507              	 .cfi_def_cfa_offset 8
 2508              	 .cfi_offset 7,-8
 2509              	 .cfi_offset 14,-4
 2510 0002 00AF     	 add r7,sp,#0
 2511              	.LCFI147:
 2512              	 .cfi_def_cfa_register 7
 705:../main.c     **** 	/* Check for Node error */
 706:../main.c     **** 	if (CAN_NODE_GetStatus(&CAN_NODE_0) & XMC_CAN_NODE_STATUS_LAST_ERROR_CODE)
 2513              	 .loc 3 706 0
 2514 0004 0E48     	 ldr r0,.L149
 2515 0006 FFF7FEFF 	 bl CAN_NODE_GetStatus
 2516 000a 0346     	 mov r3,r0
 2517 000c 03F00703 	 and r3,r3,#7
 2518 0010 002B     	 cmp r3,#0
 2519 0012 14D1     	 bne .L147
 707:../main.c     **** 	{
 708:../main.c     **** 		XMC_DEBUG("Something failed\n");
 709:../main.c     **** 	}
 710:../main.c     **** 	else if (CAN_NODE_MO_GetStatus(&CAN_NODE_0_LMO_01_Config)
 2520              	 .loc 3 710 0
 2521 0014 0B48     	 ldr r0,.L149+4
 2522 0016 FFF7FEFF 	 bl CAN_NODE_MO_GetStatus
 2523 001a 0346     	 mov r3,r0
 711:../main.c     **** 			& XMC_CAN_MO_STATUS_RX_PENDING)
 2524              	 .loc 3 711 0
 2525 001c 03F00103 	 and r3,r3,#1
 710:../main.c     **** 			& XMC_CAN_MO_STATUS_RX_PENDING)
 2526              	 .loc 3 710 0
 2527 0020 002B     	 cmp r3,#0
 2528 0022 0CD0     	 beq .L147
 712:../main.c     **** 	{
 713:../main.c     **** 		/* Read the received Message object and stores in Request_Node_LMO_02_Config*/
 714:../main.c     **** 		CAN_NODE_MO_Receive(&CAN_NODE_0_LMO_01_Config);
 2529              	 .loc 3 714 0
 2530 0024 0748     	 ldr r0,.L149+4
 2531 0026 FFF7FEFF 	 bl CAN_NODE_MO_Receive
 715:../main.c     **** 		ReceivedMsg = CAN_NODE_0_LMO_01_Config.mo_ptr;
 2532              	 .loc 3 715 0
 2533 002a 064B     	 ldr r3,.L149+4
 2534 002c 1B68     	 ldr r3,[r3]
 2535 002e 064A     	 ldr r2,.L149+8
 2536 0030 1360     	 str r3,[r2]
 716:../main.c     **** 		processTrigger(CAN_NODE_0_LMO_01_Config.mo_ptr, &SendCommand);
 2537              	 .loc 3 716 0
 2538 0032 044B     	 ldr r3,.L149+4
 2539 0034 1B68     	 ldr r3,[r3]
 2540 0036 1846     	 mov r0,r3
 2541 0038 0449     	 ldr r1,.L149+12
 2542 003a FFF7FEFF 	 bl processTrigger
 2543              	.L147:
 717:../main.c     **** 	}
 718:../main.c     **** }
 2544              	 .loc 3 718 0
 2545 003e 80BD     	 pop {r7,pc}
 2546              	.L150:
 2547              	 .align 2
 2548              	.L149:
 2549 0040 00000000 	 .word CAN_NODE_0
 2550 0044 00000000 	 .word CAN_NODE_0_LMO_01_Config
 2551 0048 00000000 	 .word ReceivedMsg
 2552 004c 00000000 	 .word SendCommand
 2553              	 .cfi_endproc
 2554              	.LFE264:
 2556              	 .text
 2557              	.Letext0:
 2558              	 .file 4 "e:\\davev4\\dave-4.1.4\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\machine\\_default_types.h"
 2559              	 .file 5 "e:\\davev4\\dave-4.1.4\\eclipse\\arm-gcc-49\\arm-none-eabi\\include\\stdint.h"
 2560              	 .file 6 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Infineon/XMC4700_series/Include/XMC4700.h"
 2561              	 .file 7 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Libraries\\XMCLib\\inc/xmc4_gpio.h"
 2562              	 .file 8 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Libraries\\XMCLib\\inc/xmc_usbd_regs.h"
 2563              	 .file 9 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Libraries\\XMCLib\\inc/xmc_usbd.h"
 2564              	 .file 10 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Dave\\Generated/USBD/usbd.h"
 2565              	 .file 11 "d:\\dholler\\dokumente\\uni\\bus\\xmc\\usbcannode\\dave\\generated\\usbd\\usb\\core\\endpoint.h"
 2566              	 .file 12 "d:\\dholler\\dokumente\\uni\\bus\\xmc\\usbcannode\\dave\\generated\\usbd_vcom\\class_driver\\common\\cdc_class_common.h"
 2567              	 .file 13 "e:\\davev4\\dave-4.1.4\\eclipse\\arm-gcc-49\\lib\\gcc\\arm-none-eabi\\4.9.3\\include\\stdarg.h"
 2568              	 .file 14 "<built-in>"
 2569              	 .file 15 "d:\\dholler\\dokumente\\uni\\bus\\xmc\\usbcannode\\dave\\generated\\usbd_vcom\\class_driver\\device/cdc_class_device.h"
 2570              	 .file 16 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Dave\\Generated/USBD_VCOM/usbd_vcom.h"
 2571              	 .file 17 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Dave\\Generated/GLOBAL_CAN/global_can.h"
 2572              	 .file 18 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Dave\\Generated/CAN_NODE/can_node.h"
 2573              	 .file 19 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Dave\\Generated/DAVE.h"
 2574              	 .file 20 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Include/core_cm4.h"
 2575              	 .file 21 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode/Libraries/CMSIS/Infineon/XMC4700_series/Include/system_XMC4700.h"
 2576              	 .file 22 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Dave\\Generated/USBD/usbd_extern.h"
 2577              	 .file 23 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Dave\\Generated/USBD_VCOM/usbd_vcom_extern.h"
 2578              	 .file 24 "D:\\dholler\\Dokumente\\uni\\bus\\xmc\\usbCanNode\\Dave\\Generated/CAN_NODE/can_node_extern.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
    {standard input}:20     .text.XMC_GPIO_SetOutputHigh:00000000 $t
    {standard input}:24     .text.XMC_GPIO_SetOutputHigh:00000000 XMC_GPIO_SetOutputHigh
    {standard input}:68     .text.XMC_GPIO_SetOutputLow:00000000 $t
    {standard input}:72     .text.XMC_GPIO_SetOutputLow:00000000 XMC_GPIO_SetOutputLow
    {standard input}:115    .text.XMC_GPIO_GetInput:00000000 $t
    {standard input}:119    .text.XMC_GPIO_GetInput:00000000 XMC_GPIO_GetInput
    {standard input}:163    .text.XMC_GPIO_EnableDigitalInput:00000000 $t
    {standard input}:167    .text.XMC_GPIO_EnableDigitalInput:00000000 XMC_GPIO_EnableDigitalInput
    {standard input}:214    .text.XMC_CAN_NODE_SetInitBit:00000000 $t
    {standard input}:218    .text.XMC_CAN_NODE_SetInitBit:00000000 XMC_CAN_NODE_SetInitBit
    {standard input}:260    .text.XMC_CAN_NODE_ResetInitBit:00000000 $t
    {standard input}:264    .text.XMC_CAN_NODE_ResetInitBit:00000000 XMC_CAN_NODE_ResetInitBit
    {standard input}:305    .text.XMC_CAN_NODE_SetAnalyzerMode:00000000 $t
    {standard input}:309    .text.XMC_CAN_NODE_SetAnalyzerMode:00000000 XMC_CAN_NODE_SetAnalyzerMode
    {standard input}:350    .text.XMC_CAN_NODE_ReSetAnalyzerMode:00000000 $t
    {standard input}:354    .text.XMC_CAN_NODE_ReSetAnalyzerMode:00000000 XMC_CAN_NODE_ReSetAnalyzerMode
    {standard input}:395    .text.XMC_CAN_MO_GetStatus:00000000 $t
    {standard input}:399    .text.XMC_CAN_MO_GetStatus:00000000 XMC_CAN_MO_GetStatus
    {standard input}:439    .text._error:00000000 $t
    {standard input}:444    .text._error:00000000 _error
    {standard input}:469    .text._error:00000010 $d
    {standard input}:478    .bss.usb_rx_buffer:00000000 usb_rx_buffer
    {standard input}:475    .bss.usb_rx_buffer:00000000 $d
    {standard input}:485    .data.messageObjects:00000000 messageObjects
    {standard input}:482    .data.messageObjects:00000000 $d
    {standard input}:523    .bss.ReceivedMsg:00000000 ReceivedMsg
    {standard input}:520    .bss.ReceivedMsg:00000000 $d
    {standard input}:530    .rodata.CommandSeperator:00000000 CommandSeperator
    {standard input}:527    .rodata.CommandSeperator:00000000 $d
    {standard input}:536    .bss.echoEnabled:00000000 echoEnabled
    {standard input}:537    .bss.echoEnabled:00000000 $d
    {standard input}:543    .data.SendCommand:00000000 SendCommand
    {standard input}:540    .data.SendCommand:00000000 $d
    {standard input}:556    .text.is_printable:00000000 $t
    {standard input}:561    .text.is_printable:00000000 is_printable
    {standard input}:613    .text.USB_CAN_printf:00000000 $t
    {standard input}:618    .text.USB_CAN_printf:00000000 USB_CAN_printf
    {standard input}:688    .rodata:00000000 $d
    {standard input}:698    .text.printCanMsg:00000000 $t
    {standard input}:703    .text.printCanMsg:00000000 printCanMsg
    {standard input}:787    .text.printCanMsg:00000064 $d
    {standard input}:794    .text.consumeCanMsg:00000000 $t
    {standard input}:799    .text.consumeCanMsg:00000000 consumeCanMsg
    {standard input}:852    .text.consumeCanMsg:00000030 $d
    {standard input}:857    .text.executeAnalyserCommand:00000000 $t
    {standard input}:862    .text.executeAnalyserCommand:00000000 executeAnalyserCommand
    {standard input}:921    .text.XMC_CAN_MO_Transmission_Ongoing:00000000 $t
    {standard input}:926    .text.XMC_CAN_MO_Transmission_Ongoing:00000000 XMC_CAN_MO_Transmission_Ongoing
    {standard input}:966    .text.sendCanMsg:00000000 $t
    {standard input}:971    .text.sendCanMsg:00000000 sendCanMsg
    {standard input}:1056   .text.sendCanMsg:0000006c $d
    {standard input}:1062   .text.executeSurgeCommand:00000000 $t
    {standard input}:1067   .text.executeSurgeCommand:00000000 executeSurgeCommand
    {standard input}:1137   .text.executeSurgeCommand:00000050 $d
    {standard input}:1143   .text.executeTriggertSendCommand:00000000 $t
    {standard input}:1148   .text.executeTriggertSendCommand:00000000 executeTriggertSendCommand
    {standard input}:1285   .text.executeSendCommand:00000000 $t
    {standard input}:1290   .text.executeSendCommand:00000000 executeSendCommand
    {standard input}:1357   .text.processSendCommand:00000000 $t
    {standard input}:1362   .text.processSendCommand:00000000 processSendCommand
    {standard input}:1672   .text.processSendCommand:000001fc $d
    {standard input}:1682   .text.processSurgeCommand:00000000 $t
    {standard input}:1687   .text.processSurgeCommand:00000000 processSurgeCommand
    {standard input}:1715   .text.processEchoCommand:00000000 $t
    {standard input}:1720   .text.processEchoCommand:00000000 processEchoCommand
    {standard input}:1771   .text.processEchoCommand:00000030 $d
    {standard input}:1777   .text.processAnalyzerCommand:00000000 $t
    {standard input}:1782   .text.processAnalyzerCommand:00000000 processAnalyzerCommand
    {standard input}:1837   .text.processAnalyzerCommand:00000038 $d
    {standard input}:1865   .text.processCommand:00000000 $t
    {standard input}:1870   .text.processCommand:00000000 processCommand
    {standard input}:2009   .text.processCommand:000000c8 $d
    {standard input}:2025   .text.USBD_VCOM_SendPromt:00000000 $t
    {standard input}:2030   .text.USBD_VCOM_SendPromt:00000000 USBD_VCOM_SendPromt
    {standard input}:2066   .text.USBD_VCOM_SendPromt:0000001c $d
    {standard input}:2071   .text.processTrigger:00000000 $t
    {standard input}:2076   .text.processTrigger:00000000 processTrigger
    {standard input}:2191   .text.processTrigger:00000098 $d
    {standard input}:2206   .text.main:00000000 $t
    {standard input}:2211   .text.main:00000000 main
    {standard input}:2481   .text.main:0000019c $d
    {standard input}:2494   .text.CAN0_1_IRQHandler:00000000 $t
    {standard input}:2499   .text.CAN0_1_IRQHandler:00000000 CAN0_1_IRQHandler
    {standard input}:2549   .text.CAN0_1_IRQHandler:00000040 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
CAN_NODE_0_LMO_01_Config
CAN_NODE_0_LMO_02_Config
CAN_NODE_0_LMO_03_Config
CAN_NODE_0_LMO_04_Config
CAN_NODE_0_LMO_05_Config
CAN_NODE_0_LMO_06_Config
CAN_NODE_0_LMO_07_Config
CAN_NODE_0_LMO_08_Config
CAN_NODE_0_LMO_09_Config
CAN_NODE_0_LMO_10_Config
CAN_NODE_0_LMO_11_Config
CAN_NODE_0_LMO_12_Config
CAN_NODE_0_LMO_13_Config
CAN_NODE_0_LMO_14_Config
CAN_NODE_0_LMO_15_Config
CAN_NODE_0_LMO_16_Config
CAN_NODE_0_LMO_17_Config
CAN_NODE_0_LMO_19_Config
CAN_NODE_0_LMO_20_Config
CAN_NODE_0_LMO_21_Config
CAN_NODE_0_LMO_22_Config
CAN_NODE_0_LMO_23_Config
CAN_NODE_0_LMO_24_Config
CAN_NODE_0_LMO_25_Config
CAN_NODE_0_LMO_26_Config
CAN_NODE_0_LMO_27_Config
CAN_NODE_0_LMO_28_Config
CAN_NODE_0_LMO_29_Config
CAN_NODE_0_LMO_30_Config
CAN_NODE_0_LMO_31_Config
CAN_NODE_0_LMO_32_Config
vsnprintf
USBD_VCOM_SendString
XMC_CAN_MO_SetIdentifier
XMC_CAN_MO_UpdateData
XMC_CAN_MO_Transmit
CAN_NODE_MO_Transmit
strsep
strcmp
strtoul
strtol
CAN_NODE_0
DAVE_Init
XMC_GPIO_SetMode
USBD_VCOM_Connect
USBD_VCOM_IsEnumDone
USBD_VCOM_BytesReceived
USBD_VCOM_ReceiveByte
memset
CDC_Device_USBTask
USBD_VCOM_cdc_interface
CAN_NODE_GetStatus
CAN_NODE_MO_GetStatus
CAN_NODE_MO_Receive
